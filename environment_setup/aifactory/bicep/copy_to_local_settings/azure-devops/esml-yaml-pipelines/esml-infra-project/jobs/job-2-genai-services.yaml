parameters:
  - name: serviceConnection
    type: string
  - name: serviceConnectionSeeding
    type: string

steps:
- task: AzureCLI@2
  displayName: '00_resolve_network_env_placeholders'
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
      #!/bin/bash
      
      NETWORK_ENV="$(network_env)"
      VNET_RG="$(vnetResourceGroup_param)"
      VNET_NAME="$(vnetNameFull_param)"
      
      echo "Original vnetResourceGroup_param: $VNET_RG"
      echo "Original vnetNameFull_param: $VNET_NAME"
      echo "network_env value: $NETWORK_ENV"
      
      # Replace <network_env> placeholder in VNET_RG if it exists
      if [[ "$VNET_RG" == *"<network_env>"* ]]; then
        echo "Found <network_env> placeholder in vnetResourceGroup_param"
        VNET_RG="${VNET_RG//<network_env>/$NETWORK_ENV}"
        echo "Replaced with network_env value: $NETWORK_ENV"
      fi
      
      # Replace <network_env> placeholder in VNET_NAME if it exists
      if [[ "$VNET_NAME" == *"<network_env>"* ]]; then
        echo "Found <network_env> placeholder in vnetNameFull_param"
        VNET_NAME="${VNET_NAME//<network_env>/$NETWORK_ENV}"
        echo "Replaced with network_env value: $NETWORK_ENV"
      fi
      
      # If VNET variables are not set (empty or unexpanded), use naming convention
      if [ -z "$VNET_NAME" ] || [[ "$VNET_NAME" == \$\(vnetNameFull_param\)* ]]; then
        VNET_NAME="$(vnetNameBase)-$(admin_locationSuffix)-$(dev_test_prod)$(admin_commonResourceSuffix)"
        echo "VNET name not set, using naming convention: $VNET_NAME"
      else
        echo "Using provided VNET name: $VNET_NAME"
      fi
      
      if [ -z "$VNET_RG" ] || [[ "$VNET_RG" == \$\(vnetResourceGroup_param\)* ]]; then
        # Use the common resource group naming convention
        VNET_RG="$(admin_aifactoryPrefixRG)$(vnetResourceGroupBase)-$(admin_locationSuffix)-$(dev_test_prod)$(admin_aifactorySuffixRG)"
        echo "VNET resource group not set, using naming convention: $VNET_RG"
      else
        echo "Using provided VNET resource group: $VNET_RG"
      fi
      
      # Set resolved values as pipeline variables for reuse
      echo "##vso[task.setvariable variable=vnetResourceGroup_resolved]$VNET_RG"
      echo "##vso[task.setvariable variable=vnetNameFull_resolved]$VNET_NAME"
      
      echo "Resolved vnetResourceGroup: $VNET_RG"
      echo "Resolved vnetNameFull: $VNET_NAME"
      echo "Variables set: vnetResourceGroup_resolved and vnetNameFull_resolved"
- task: AzureCLI@2
  displayName: '00_validate_project_subnet_exists'
  condition: and(ne(variables['debug_disable_validation_tasks'], 'true'), ne(variables['BYO_subnets'], 'true'))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
      #!/bin/bash
      
      az account set --subscription "$(dev_test_prod_sub_id)"
      
      # Construct subnet name based on project number
      PROJECT_SUBNET_NAME="snt-prj$(project_number_000)-aks"
      echo "Checking for subnet: $PROJECT_SUBNET_NAME"
      
      # Get vnet information from variables, with fallback to naming convention
      VNET_NAME="$(vnetNameFull_param)"
      VNET_RG="$(vnetResourceGroup_resolved)"

      # If VNET variables are not set (empty or unexpanded), use naming convention
      if [ -z "$VNET_NAME" ] || [[ "$VNET_NAME" == \$\(vnetNameFull_param\)* ]]; then
        VNET_NAME="$(vnetNameBase)-$(admin_locationSuffix)-$(dev_test_prod)$(admin_commonResourceSuffix)"
        echo "VNET name not set, using naming convention: $VNET_NAME"
      else
        echo "Using provided VNET name: $VNET_NAME"
      fi
      
      if [ -z "$VNET_RG" ] || [[ "$VNET_RG" == \$\(vnetResourceGroup_param\)* ]]; then
        # Use the common resource group naming convention
        VNET_RG="$(admin_aifactoryPrefixRG)$(vnetResourceGroupBase)-$(admin_locationSuffix)-$(dev_test_prod)$(admin_aifactorySuffixRG)"
        echo "VNET resource group not set, using naming convention: $VNET_RG"
      else
        echo "Using provided VNET resource group: $VNET_RG"
      fi
      
      echo "VNET Name: $VNET_NAME"
      echo "VNET Resource Group: $VNET_RG"
      
      # First check if VNET exists
      if ! az network vnet show --name "$VNET_NAME" --resource-group "$VNET_RG" &> /dev/null; then
        echo "‚ùå ERROR: VNET '$VNET_NAME' does not exist in resource group '$VNET_RG'"
        echo "Please ensure the common networking infrastructure is deployed first."
        exit 1
      fi
      
      # Check if project AKS subnet exists
      if az network vnet subnet show --name "$PROJECT_SUBNET_NAME" --vnet-name "$VNET_NAME" --resource-group "$VNET_RG" &> /dev/null; then
        echo "‚úÖ Subnet '$PROJECT_SUBNET_NAME' exists. Continuing with deployment."
      else
        echo "‚ùå ERROR: Subnet '$PROJECT_SUBNET_NAME' does not exist in vnet '$VNET_NAME'"
        echo ""
        echo "Required subnet missing for GenAI services deployment."
        echo "Solutions:"
        echo "1. Set 'runNetworkingVar' to 'true' if this is the first time setting up this project"
        echo "2. Ensure project-specific networking has been deployed"
        echo "3. Verify the project number $(project_number_000) is correct"
        echo ""
        echo "Expected subnet name: $PROJECT_SUBNET_NAME"
        echo "Target VNET: $VNET_NAME"
        echo "Target Resource Group: $VNET_RG"
        echo ""
        echo "Failing pipeline..."
        exit 1
      fi

- task: PowerShell@2
  displayName: '00_check_for_submodule'
  condition: ne(variables['debug_disable_validation_tasks'], 'true')
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "=== MANUAL SUBMODULE INITIALIZATION ==="
      Write-Host "Current directory: $(Get-Location)"
      Write-Host "Working directory: $(System.DefaultWorkingDirectory)"
      
      # Change to the repository root
      Set-Location "$(System.DefaultWorkingDirectory)"
      Write-Host "Changed to: $(Get-Location)"
      
      # Check if .gitmodules exists
      if (Test-Path ".gitmodules") {
        Write-Host "‚úÖ .gitmodules file found"
        Write-Host "Contents of .gitmodules:"
        Get-Content ".gitmodules"
        
        # Initialize and update submodules manually
        Write-Host "Running: git submodule init"
        git submodule init
        
        Write-Host "Running: git submodule update --recursive"
        git submodule update --recursive
        
        Write-Host "Submodule branch information:"
        cd azure-enterprise-scale-ml
        $currentBranch = git branch --show-current
        if ($currentBranch) {
          Write-Host "‚úÖ Current branch: $currentBranch"
        } else {
          Write-Host "‚úÖ Detached HEAD - checking commit info:"
          $commitInfo = git log --oneline -1
          Write-Host "   Current commit: $commitInfo"
        }
        
        Write-Host "Available branches:"
        git branch -a | ForEach-Object { 
          $branch = $_.Trim()
          if ($branch -match "remotes/origin/(main|release/.*)") {
            Write-Host "   $branch"
          }
        }
        cd ..
      } else {
        Write-Host "‚ùå .gitmodules file NOT found"
      }
      
      Write-Host "Final directory contents:"
      Get-ChildItem | Format-Table Name, IsDirectory
      Write-Host "=== END MANUAL SUBMODULE INIT ==="

- task: AzureCLI@2
  displayName: '00_generate_deployment_random_value'
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: pscore
    scriptLocation: inlineScript
    inlineScript: |
      # Generate a random deployment ID for this entire pipeline run
      $randomValue = [System.Guid]::NewGuid().ToString("N").Substring(0, 10)
      Write-Host "Generated deployment random value: $randomValue"
      echo "##vso[task.setvariable variable=deployment_random_value]$randomValue"

- task: AzureCLI@2
  displayName: '00_pwsh_print_info'
  condition: ne(variables['debug_disable_validation_tasks'], 'true')
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: pscore
    scriptLocation: inlineScript
    inlineScript: |
        Write-Host " - AI FACTORY: NAMING"
        Write-Host "projectPrefix (esml-) is: $(projectPrefix)"
        Write-Host "projectSuffix (-rg) is: $(projectSuffix)"
        Write-Host "dev_test_prod is: $(dev_test_prod)"
        Write-Host "AI Factory version is: $(aifactory_version_major).$(aifactory_version_minor)"
        Write-Host "AI Factory scale set (-001) is: $(admin_aifactorySuffixRG)"
        Write-Host "Resource group suffix (-001) is: $(admin_commonResourceSuffix)"
        Write-Host "project_number_000 (001) is: $(project_number_000)"
        Write-Host "admin_projectType (all) is: $(admin_projectType)"
        Write-Host " - NETWORKING:"
        Write-Host "runNetworkingVar (true) is: $(runNetworkingVar)"
        Write-Host "allowPublicAccessWhenBehindVnet is: $(allowPublicAccessWhenBehindVnet)"
        Write-Host "enablePublicGenAIAccess is: $(enablePublicGenAIAccess)"
        Write-Host "enablePublicAccessWithPerimeter is: $(enablePublicAccessWithPerimeter)"
        Write-Host "privDnsResourceGroup_param is: $(privDnsResourceGroup_param)"
        Write-Host "centralDnsZoneByPolicyInHub (false) is: $(centralDnsZoneByPolicyInHub)"
        Write-Host "vnetResourceGroup_param ("") is: $(vnetResourceGroup_param)"
        Write-Host "vnetNameFull_param ("") is: $(vnetNameFull_param)"
        Write-Host "commonResourceGroup_param ("") is : $(commonResourceGroup_param)"
        Write-Host "vnetNameBase is: $(vnetNameBase)"
        Write-Host "BYO_subnets (false) is : $(BYO_subnets)"
        Write-Host "vnetResourceGroupBase (esml-common) is: $(vnetResourceGroupBase)"
        Write-Host "common_subnet_name (common_subnet_name) is: $(common_subnet_name)"
        Write-Host " - ENCRYPTION:"
        Write-Host "CMK (false): $(cmk)"
        Write-Host "cmkKeyName (aifactory-cmk-key): $(cmkKeyName)"
        Write-Host "useCommonACR (true): $(useCommonACR)"
        Write-Host " - FOUNDRY:"
        Write-Host "Foundry:enableAFoundryCaphost (false) is: $(enableAFoundryCaphost)"
        Write-Host "Foundry:disableAgentNetworkInjection (true) is: $(disableAgentNetworkInjection)"
        Write-Host " - PERMISSION and OTHER:"
        Write-Host "use_ad_groups (true) is: $(use_ad_groups)"
        Write-Host "service_connection is:  ${{ parameters.serviceConnection }}"
        Write-Host "dev_service_connection is: $(dev_service_connection)"
        Write-Host "deployment_random_value is: $(deployment_random_value)"
- task: AzureCLI@2
  displayName: '01_pwsh_get_IP_for_ADO_agent'
  condition: ne(variables['disable_whitelisting_for_build_agents'], 'true')
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
      # Get primary IP
      PRIMARY_IP=$(curl -s http://ipinfo.io/ip)
      echo "Primary IP: $PRIMARY_IP"
      echo "##vso[task.setvariable variable=admin_ip_fw]$PRIMARY_IP"
      
      # Get all possible IPs that might be used
      echo "All network interfaces:"
      ip addr show | grep 'inet ' | grep -v '127.0.0.1' | awk '{print $2}' | cut -d'/' -f1
      
      # Try alternative IP detection services
      ALT_IP1=$(curl -s https://api.ipify.org)
      ALT_IP2=$(curl -s https://checkip.amazonaws.com)
      
      echo "Alternative IP 1: $ALT_IP1"
      echo "Alternative IP 2: $ALT_IP2"
      
      # Set variables for all IPs
      echo "##vso[task.setvariable variable=admin_ip_fw_alt1]$ALT_IP1"
      echo "##vso[task.setvariable variable=admin_ip_fw_alt2]$ALT_IP2"

- task: AzureCLI@2
  displayName: '02_az_set_ip_to_seeding_keyvault_FW_whitelist'
  condition: ne(variables['disable_whitelisting_for_build_agents'], 'true')
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: | 
     az account set --subscription "$(admin_bicep_input_keyvault_subscription)"
     
     az keyvault update --name "$(admin_bicep_kv_fw)" --resource-group "$(admin_bicep_kv_fw_rg)" --public-network-access Enabled --default-action Deny
     echo "Waiting for network rules to propagate..."
     sleep 10
     
     az keyvault network-rule add --resource-group "$(admin_bicep_kv_fw_rg)" --name "$(admin_bicep_kv_fw)" --ip-address "$(admin_ip_fw)"
- task: AzureKeyVault@2
  displayName: '03_az_download_seeding_keyvault'
  inputs:
    azureSubscription: ${{ parameters.serviceConnectionSeeding }}
    KeyVaultName: '$(admin_bicep_kv_fw)'
- task: AzureCLI@2
  displayName: '03b_create_temp_json_files'
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: pscore
    scriptLocation: inlineScript
    inlineScript: |
      # Create temporary JSON files from YAML variables with correct filenames expected by task 04
      $tempDir = "$(System.DefaultWorkingDirectory)/aifactory/parameters/"
      New-Item -ItemType Directory -Force -Path $tempDir
      
      # 10-esml-globals-1.json (bicepPar1)
      $globals1 = @{
        '$schema' = "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#"
        contentVersion = "1.0.0.0"
        parameters = @{
          aifactorySuffixRG = @{ value = "$(admin_aifactorySuffixRG)" }
          commonRGNamePrefix = @{ value = "$(admin_aifactoryPrefixRG)" }
          locationSuffix = @{ value = "$(admin_locationSuffix)" }
          location = @{ value = "$(admin_location)" }
        }
      }
      $globals1 | ConvertTo-Json -Depth 5 | Out-File "$tempDir/10-esml-globals-1.json" -Encoding UTF8
      
      # 10-esml-globals-2-12_13_21_22.json (bicepPar2)
      $globals2 = @{
        '$schema' = "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#"
        contentVersion = "1.0.0.0"
        parameters = @{
          commonResourceSuffix = @{ value = "$(admin_commonResourceSuffix)" }
          vnetNameBase = @{ value = "$(vnetNameBase)" }
        }
      }
      $globals2 | ConvertTo-Json -Depth 5 | Out-File "$tempDir/10-esml-globals-2-12_13_21_22.json" -Encoding UTF8
      
      # 10-esml-globals-4-13_21_22.json (bicepPar3) - Add more parameters that are commonly needed
      $globals4 = @{
        '$schema' = "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#"
        contentVersion = "1.0.0.0"
        parameters = @{
          resourceSuffix = @{ value = "$(admin_prjResourceSuffix)" }
          tenantId = @{ value = "$(tenantId)" }
        }
      }
      $globals4 | ConvertTo-Json -Depth 5 | Out-File "$tempDir/10-esml-globals-4-13_21_22.json" -Encoding UTF8
      
      # 21-22-esml-prj-parameters.json (bicepPar4)
      $project = @{
        '$schema' = "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#"
        contentVersion = "1.0.0.0"
        parameters = @{
          vnetResourceGroupBase = @{ value = "$(vnetResourceGroupBase)" }
        }
      }
      $project | ConvertTo-Json -Depth 5 | Out-File "$tempDir/21-22-esml-prj-parameters.json" -Encoding UTF8
      
      # 10-esml-globals-override.json (bicepPar5) - Use resolved variables with <network_env> already replaced
      $override = @{
        '$schema' = "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#"
        contentVersion = "1.0.0.0"
        parameters = @{
          vnetResourceGroup_param = @{ value = "$(vnetResourceGroup_resolved)" }
          vnetNameFull_param = @{ value = "$(vnetNameFull_resolved)" }
          subnetCommon = @{ value = "$(subnetCommon)" }
          subnetCommonScoring = @{ value = "$(subnetCommonScoring)" }
          subnetCommonPowerbiGw = @{ value = "$(subnetCommonPowerbiGw)" }
          subnetProjGenAI = @{ value = "$(subnetProjGenAI)" }
          subnetProjAKS = @{ value = "$(subnetProjAKS)" }
          subnetProjAKS2 = @{ value = "$(subnetProjAKS2)" }
          subnetProjACA = @{ value = "$(subnetProjACA)" }
          subnetProjACA2 = @{ value = "$(subnetProjACA2)" }
          subnetProjDatabricksPublic = @{ value = "$(subnetProjDatabricksPublic)" }
          subnetProjDatabricksPrivate = @{ value = "$(subnetProjDatabricksPrivate)" }
        }
      }
      $override | ConvertTo-Json -Depth 5 | Out-File "$tempDir/10-esml-globals-override.json" -Encoding UTF8
      
      Write-Host "Parameter JSON files created successfully with correct filenames:"
      Write-Host "- 10-esml-globals-1.json"
      Write-Host "- 10-esml-globals-2-12_13_21_22.json" 
      Write-Host "- 10-esml-globals-4-13_21_22.json"
      Write-Host "- 21-22-esml-prj-parameters.json"
      Write-Host "- 10-esml-globals-override.json"
      
      # Debug: Show actual paths and verify files exist
      Write-Host "Files created in directory: $tempDir"
      Write-Host "Current working directory: $(Get-Location)"
      Write-Host "Verifying files exist:"
      Get-ChildItem -Path $tempDir -Filter "*.json" | ForEach-Object { Write-Host "  Found: $($_.FullName)" }
- task: PowerShell@2
  displayName: '04_debug_check_files_and_paths'
  condition: ne(variables['debug_disable_validation_tasks'], 'true')
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "=== DEBUG: Checking file paths and submodule checkout ==="
      Write-Host "Current working directory: $(Get-Location)"
      Write-Host "System.DefaultWorkingDirectory: $(System.DefaultWorkingDirectory)"
      Write-Host "Contents of $(System.DefaultWorkingDirectory):"
      Get-ChildItem "$(System.DefaultWorkingDirectory)" | Format-Table Name, IsDirectory
      
      if (Test-Path "$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml") {
        Write-Host "‚úÖ azure-enterprise-scale-ml submodule exists"
        Write-Host "Contents of azure-enterprise-scale-ml:"
        Get-ChildItem "$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml" | Format-Table Name, IsDirectory
        
        $scriptPath = "$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep/scripts"
        if (Test-Path $scriptPath) {
          Write-Host "‚úÖ Scripts directory exists: $scriptPath"
          Write-Host "Contents of scripts directory:"
          Get-ChildItem $scriptPath | Format-Table Name
          
          $fullScriptPath = "$scriptPath/genDynamicNetworkParamFile.ps1"
          if (Test-Path $fullScriptPath) {
            Write-Host "‚úÖ Script file exists: $fullScriptPath"
          } else {
            Write-Host "‚ùå Script file NOT found: $fullScriptPath"
          }
        } else {
          Write-Host "‚ùå Scripts directory NOT found: $scriptPath"
        }
      } else {
        Write-Host "‚ùå azure-enterprise-scale-ml submodule NOT found"
      }
      Write-Host "=== END DEBUG ==="

- task: AzureCLI@2
  displayName: '04_pwsh_fetch_network_parameters'
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: pscore
    ScriptPath: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep/scripts/genDynamicNetworkParamFile.ps1'
    arguments: '-spObjId "$(esml-common-bicep-sp-id)" -spSecret "$(esml-common-bicep-sp-secret)" -BYO_subnets "$(BYO_subnets)" -network_env "$(network_env)" -useServicePrincipal -bicepPar1 "../../../../../aifactory/parameters/10-esml-globals-1.json" -bicepPar2 "../../../../../aifactory/parameters/10-esml-globals-2-12_13_21_22.json" -bicepPar3 "../../../../../aifactory/parameters/10-esml-globals-4-13_21_22.json" -bicepPar4 "../../../../../aifactory/parameters/21-22-esml-prj-parameters.json" -bicepPar5 "../../../../../aifactory/parameters/10-esml-globals-override.json" -filePath "../../../../../aifactory/parameters/" -env "$(dev_test_prod)" -locationSuffixADO "$(admin_locationSuffix)" -aifactorySuffixRGADO "$(admin_aifactorySuffixRG)" -projectNumber "$(project_number_000)" -subscriptionId "$(dev_test_prod_sub_id)" -commonRGNamePrefixVar "$(admin_aifactoryPrefixRG)" -projectTypeADO "$(admin_projectType)"'
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep/scripts'
- task: AzureCLI@2
  displayName: '05a_Check if Private DNS Zones exist'
  condition: ne(variables['debug_disable_validation_tasks'], 'true')
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
      #!/bin/bash

      # Input parameters
      # Use privDnsSubscription_param if available, otherwise use dev_test_prod_sub_id
      PRIV_DNS_SUB_PARAM="$(privDnsSubscription_param)"
      if [ -n "$PRIV_DNS_SUB_PARAM" ] && [ "$PRIV_DNS_SUB_PARAM" != "\$(privDnsSubscription_param)" ]; then
        privDnsSubscription="$PRIV_DNS_SUB_PARAM"
        echo "Using privDnsSubscription_param: $privDnsSubscription"
      else
        privDnsSubscription="$(dev_test_prod_sub_id)"
        echo "Using dev_test_prod_sub_id for Private DNS subscription: $privDnsSubscription"
      fi

      az account set --subscription "$privDnsSubscription"
      
      # Use privDnsResourceGroup_param if available, otherwise construct the name
      PRIV_DNS_RG_PARAM="$(privDnsResourceGroup_param)"
      if [ -n "$PRIV_DNS_RG_PARAM" ] && [ "$PRIV_DNS_RG_PARAM" != "\$(privDnsResourceGroup_param)" ]; then
        privDnsResourceGroupName="$PRIV_DNS_RG_PARAM"
        echo "Using privDnsResourceGroup_param for Private DNS: $privDnsResourceGroupName"
      else
        privDnsResourceGroupName="$(admin_aifactoryPrefixRG)$(vnetResourceGroupBase)-$(admin_locationSuffix)-$(dev_test_prod)$(admin_aifactorySuffixRG)"
        echo "Using constructed Private DNS resource group name: $privDnsResourceGroupName"
      fi
      
      location="$(admin_location)"

      # Define DNS Zones as space-separated pairs (variable_name:dns_zone_name)
      # Using a simple approach compatible with all shell versions
      dnsZonePairs=(
        "zoneazurecontainerapps:privatelink.${location}.azurecontainerapps.io"
        "zoneredis:privatelink.redis.cache.windows.net"
        "zonepostgres:privatelink.postgres.database.azure.com"
        "zonesql:privatelink.database.windows.net"
        "zoneMongo:privatelink.mongo.cosmos.azure.com"
        "zoneServicesAi:privatelink.services.ai.azure.com"
        "zoneAPIM:privatelink.azure-api.net"
      )

      # Get vnet information for link checking
      VNET_NAME="$(vnetNameFull_resolved)"
      VNET_RG="$(vnetResourceGroup_resolved)"
      VNET_SUBSCRIPTION="$(dev_test_prod_sub_id)"
      
      # Print variables for debugging before checking
      echo "=== DNS Zone Check Configuration ==="
      echo "Private DNS Subscription: $privDnsSubscription"
      echo "Private DNS Resource Group: $privDnsResourceGroupName"
      echo "Location: $location"
      echo "VNet Name: $VNET_NAME"
      echo "VNet Resource Group: $VNET_RG"
      echo "===================================="

      # Helper function to check if a Private DNS Zone exists (log VNet link status but don't fail on missing link)
      dns_zone_and_link_exists() {
        local subscription="$1"
        local resourceGroup="$2"
        local dnsZoneName="$3"
        local vnetName="$4"
        local vnetRg="$5"
        local vnetSub="$6"

        # Send debug output to stderr so it doesn't interfere with the return value
        echo "Checking DNS Zone: $dnsZoneName in RG: $resourceGroup, Subscription: $subscription" >&2
        
        # Validate inputs
        if [ -z "$vnetName" ] || [ -z "$vnetRg" ]; then
          echo "  ‚ö†Ô∏è  WARNING: VNet name or RG is empty. VNet Name: '$vnetName', VNet RG: '$vnetRg'" >&2
          echo "  Falling back to zone-only check..." >&2
        fi
        
        # First check if the DNS zone exists
        local output
        output=$(az network private-dns zone show --subscription "$subscription" --resource-group "$resourceGroup" --name "$dnsZoneName" 2>&1)
        local zone_status=$?

        if [ $zone_status -ne 0 ]; then
          echo "  ‚ùå DNS Zone not found" >&2
          echo "  Error details: $output" >&2
          echo "false"
          return
        fi
        
        echo "  ‚úÖ DNS Zone found" >&2
        
        # If vnet parameters are missing, only check zone existence (legacy behavior)
        if [ -z "$vnetName" ] || [ -z "$vnetRg" ]; then
          echo "  ‚ö†Ô∏è  Skipping VNet link check due to missing VNet parameters" >&2
          echo "true"
          return
        fi
        
        # Now check if vnet link exists for this zone
        echo "  üîç Checking vnet links for zone..." >&2
        echo "  VNet Full Name: $vnetName" >&2
        echo "  VNet Resource Group: $vnetRg" >&2
        
        # Use the VNet's subscription (may differ from DNS subscription)
        local vnet_full_id="/subscriptions/$vnetSub/resourceGroups/$vnetRg/providers/Microsoft.Network/virtualNetworks/$vnetName"
        echo "  Expected VNet ID: $vnet_full_id" >&2
        
        # List all vnet links for this zone and check if our vnet is linked
        local links_output
        links_output=$(az network private-dns link vnet list --subscription "$subscription" --resource-group "$resourceGroup" --zone-name "$dnsZoneName" --query "[?virtualNetwork.id=='$vnet_full_id'].name" -o tsv 2>&1)
        local links_status=$?
        
        echo "  VNet link query status: $links_status" >&2
        echo "  VNet link query output: '$links_output'" >&2
        
        if [ $links_status -eq 0 ] && [ -n "$links_output" ]; then
          echo "  ‚úÖ VNet link EXISTS for this zone (link name: $links_output)" >&2
        elif [ $links_status -eq 0 ]; then
          echo "  ‚ö†Ô∏è  Zone found but no VNet link to expected VNet" >&2
        else
          echo "  ‚ö†Ô∏è  Unable to query VNet links (status $links_status); not failing zone existence" >&2
          echo "  Raw output: $links_output" >&2
        fi

        # Per requirement: only zone absence should return false
        echo "true"
      }

      # Check each DNS Zone and its vnet link
      for pair in "${dnsZonePairs[@]}"; do
        # Split the pair by colon
        key="${pair%%:*}"
        dnsZoneName="${pair#*:}"
        
        exists=$(dns_zone_and_link_exists "$privDnsSubscription" "$privDnsResourceGroupName" "$dnsZoneName" "$VNET_NAME" "$VNET_RG" "$VNET_SUBSCRIPTION")
        echo "##vso[task.setvariable variable=${key}Exists]${exists}"
        echo "Result - DNS Zone: $dnsZoneName, Zone and VNet Link Exists: $exists"
      done
- task: AzureCLI@2
  displayName: '05b_Check if resource exists'
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
      #!/bin/bash

      az account set --subscription "$(dev_test_prod_sub_id)"

      # Input parameters
      commonRGNamePrefix="$(admin_aifactoryPrefixRG)"
      projectNumber="$(project_number_000)"
      projectName="prj${projectNumber}"
      locationSuffix="$(admin_locationSuffix)"
      envName="$(dev_test_prod)"
      aifactorySuffixRG="$(admin_aifactorySuffixRG)"
      # uniqueInAIFenv="$(aifactory_salt)" # not used in this script. fuzzy match is used instead.
      resourceSuffix="$(admin_prjResourceSuffix)"
      prjResourceSuffixNoDash="${resourceSuffix#-}"
      twoNumbers="${resourceSuffix:2:2}"
      
      # Set project prefix and suffix from pipeline variables
      projectPrefix="$(projectPrefix)"
      projectSuffix="$(projectSuffix)"

      # Construct resource group name
      projectNameReplaced="${projectName/prj/project}"
      targetResourceGroup="${commonRGNamePrefix}${projectPrefix}${projectNameReplaced}-${locationSuffix}-${envName}${aifactorySuffixRG}${projectSuffix}"

      # Debug resource group construction
      echo "=== RESOURCE GROUP CONSTRUCTION DEBUG ==="
      echo "commonRGNamePrefix: '$commonRGNamePrefix'"
      echo "projectPrefix: '$projectPrefix'"
      echo "projectNameReplaced: '$projectNameReplaced'"
      echo "locationSuffix: '$locationSuffix'"
      echo "envName: '$envName'"
      echo "aifactorySuffixRG: '$aifactorySuffixRG'"
      echo "projectSuffix: '$projectSuffix'"
      echo "Final targetResourceGroup: '$targetResourceGroup'"
      echo "================================================"

      # Check if target resource group exists
      echo "Checking if resource group exists: $targetResourceGroup"
      if ! az group show --name "$targetResourceGroup" &> /dev/null; then
        echo "Resource group '$targetResourceGroup' does not exist."
        return 1
        
        # Set all resource existence variables to false
        echo "##vso[task.setvariable variable=aiHubExists]false"
        echo "##vso[task.setvariable variable=aifProjectExists]false"
        echo "##vso[task.setvariable variable=amlExists]false"
        echo "##vso[task.setvariable variable=openaiExists]false"
        echo "##vso[task.setvariable variable=aiSearchExists]false"
        echo "##vso[task.setvariable variable=dashboardInsightsExists]false"
        echo "##vso[task.setvariable variable=applicationInsightExists]false"
        echo "##vso[task.setvariable variable=aiServicesExists]false"
        echo "##vso[task.setvariable variable=bingExists]false"
        echo "##vso[task.setvariable variable=containerAppsEnvExists]false"
        echo "##vso[task.setvariable variable=containerAppAExists]false"
        echo "##vso[task.setvariable variable=containerAppWExists]false"
        echo "##vso[task.setvariable variable=cosmosDBExists]false"
        echo "##vso[task.setvariable variable=functionAppExists]false"
        echo "##vso[task.setvariable variable=webAppExists]false"
        echo "##vso[task.setvariable variable=funcAppServicePlanExists]false"
        echo "##vso[task.setvariable variable=webAppServicePlanExists]false"
        echo "##vso[task.setvariable variable=keyvaultExists]false"
        echo "##vso[task.setvariable variable=miACAExists]false"
        echo "##vso[task.setvariable variable=miPrjExists]false"
        echo "##vso[task.setvariable variable=storageAccount1001Exists]false"
        echo "##vso[task.setvariable variable=storageAccount2001Exists]false"
        echo "##vso[task.setvariable variable=aifExists]false"
        echo "##vso[task.setvariable variable=redisExists]false"
        echo "##vso[task.setvariable variable=postgreSQLExists]false"
        echo "##vso[task.setvariable variable=sqlServerExists]false"
        echo "##vso[task.setvariable variable=sqlDBExists]false"
        echo "##vso[task.setvariable variable=acrProjectExists]false"
        echo "##vso[task.setvariable variable=vmExists]false"
        
        exit 0
      fi

      echo "Resource group '$targetResourceGroup' exists. Proceeding with resource checks."

      # Helper function for fuzzy resource existence check
      resource_exists_fuzzy() {
        local rg="$1"
        local type="$2"
        local prefix="$3"
        local suffix="$4"

        # Debug output for managed identity checks (send to stderr so it doesn't interfere with return value)
        if [ "$type" = "Microsoft.ManagedIdentity/userAssignedIdentities" ]; then
          echo "DEBUG: Checking managed identity in RG: $rg" >&2
          echo "DEBUG: Looking for prefix: $prefix" >&2
        fi

        # Run the az resource list command and capture its output and exit status
        local output
        # For managed identities and other resources with random salts, use more flexible matching
        if [ "$type" = "Microsoft.ManagedIdentity/userAssignedIdentities" ]; then
          # For managed identities, only check prefix since they have random salts
          output=$(az resource list --resource-group "$rg" --resource-type "$type" --query "[?starts_with(name, '$prefix')]" 2>&1)
          echo "DEBUG: Command executed: az resource list --resource-group '$rg' --resource-type '$type' --query \"[?starts_with(name, '$prefix')]\"" >&2
        else
          # For other resources, use the original logic
          output=$(az resource list --resource-group "$rg" --resource-type "$type" --query "[?starts_with(name, '$prefix') && ends_with(name, '$suffix') ]" 2>&1)
        fi
        local status=$?

        # Debug output for managed identity checks (send to stderr)
        if [ "$type" = "Microsoft.ManagedIdentity/userAssignedIdentities" ]; then
          echo "DEBUG: Command status: $status" >&2
          echo "DEBUG: Raw output: $output" >&2
        fi

        # Check if the command succeeded
        if [ $status -ne 0 ]; then
          echo "Error: Failed to list resources in resource group '$rg' with type '$type'." >&2
          echo "Details: $output" >&2
          return 1
        fi

        # Check if the resource exists
        if echo "$output" | grep -q "$prefix"; then
          if [ "$type" = "Microsoft.ManagedIdentity/userAssignedIdentities" ]; then
            echo "DEBUG: Found managed identity matching prefix" >&2
          fi
          echo "true"
        else
          if [ "$type" = "Microsoft.ManagedIdentity/userAssignedIdentities" ]; then
            echo "DEBUG: No managed identity found matching prefix" >&2
          fi
          echo "false"
        fi
      }

      # Helper function for exact resource existence check
      resource_exists_exact() {
        local rg="$1"
        local type="$2"
        local name="$3"
        if az resource show --resource-group "$rg" --name "$name" --resource-type "$type" &> /dev/null; then
          echo "true"
        else
          echo "false"
        fi
      }

      # ...existing code...

      # Resource name variables
      noSuffix=""
      suffixStandard="${resourceSuffix}"
      suffixStandardNoDash="${prjResourceSuffixNoDash}"
      suffixStorage1=$(echo "1${prjResourceSuffixNoDash}${envName}" | tr -d '-')
      suffixStorage2=$(echo "2${prjResourceSuffixNoDash}${envName}" | tr -d '-')
      suffixAppServicePlan="${resourceSuffix}-plan"
      suffixAcr="${prjResourceSuffixNoDash}"
      suffixKeyvault="${twoNumbers}"

      aiHubName="aif-hub-${projectNumber}-${locationSuffix}-${envName}"
      aifProjectName="aif-p-${projectNumber}-1-${locationSuffix}-${envName}"
      aiFoundryV2Name="aif2"
      aiFoundryV2ProjectName="aif2-p${projectNumber}"

      botServiceName="bot-${projectNumber}-${locationSuffix}-${envName}"
      dataFactoryName="adf-${projectNumber}-${locationSuffix}-${envName}"
      aksName="aks${projectNumber}-${locationSuffix}-${envName}"
      amlName="aml-${projectNumber}-${locationSuffix}-${envName}"
      openaiName="aoai-${projectName}-${locationSuffix}-${envName}"
      safeNameAISearch="aisearch${projectName}${locationSuffix}${envName}"
      dashboardInsightsName="AIFactory${aifactorySuffixRG}-${projectName}-insights-${envName}"
      applicationInsightName="ain-${projectName}-${locationSuffix}-${envName}"
      aiServicesPrefix="aiservices${projectName}${locationSuffix}${envName}"
      bingName="bing-${projectName}-${locationSuffix}-${envName}"
      containerAppsEnvName="aca-env-${projectName}-${locationSuffix}-${envName}"
      containerAppAName="aca-a-${projectName}${locationSuffix}${envName}"
      containerAppWName="aca-w-${projectName}${locationSuffix}${envName}"
      cosmosDBName="cosmos-${projectName}-${locationSuffix}-${envName}"
      functionAppName="func-${projectName}-${locationSuffix}-${envName}"
      webAppName="webapp-${projectName}-${locationSuffix}-${envName}"
      funcAppServicePlanName="func-${projectName}-${locationSuffix}-${envName}"
      webbAppServicePlanName="webapp-${projectName}-${locationSuffix}-${envName}"
      keyvaultName="kv-p${projectNumber}-${locationSuffix}-${envName}"
      miACAPrefix="mi-aca-${projectName}-${locationSuffix}-${envName}"
      miPrjPrefix="mi-${projectName}-${locationSuffix}-${envName}"
      storageAccount1001Name="sa${projectName}${locationSuffix}"
      storageAccount2001Name="sa${projectName}${locationSuffix}"
      aifName="aif-hub-${projectName}-${locationSuffix}-${envName}"
      redisName="redis-${projectName}-${locationSuffix}-${envName}"
      postgreSQLName="pg-flex-${projectName}-${locationSuffix}-${envName}"
      sqlServerName="sql-${projectName}-${locationSuffix}-${envName}"
      sqlDBName="sqldb-${projectName}-${locationSuffix}-${envName}"
      acrProjectName="acr${projectName}genai${locationSuffix}"
      vmName="dsvm-${projectName}-${locationSuffix}-${envName}"
      logicAppsName="adf-${projectNumber}-${locationSuffix}-${envName}"
      eventHubsName="eh-${projectNumber}-${locationSuffix}-${envName}"
      databricksName="dbx-${projectNumber}-${locationSuffix}-${envName}"

      # Check resources (fuzzy for those with randomSalt,unique, exact for others)
      echo "##vso[task.setvariable variable=aiHubExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.MachineLearningServices/workspaces" "$aiHubName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=aifProjectExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.MachineLearningServices/workspaces" "$aifProjectName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=aiFoundryV2Exists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.CognitiveServices/accounts" "$aiFoundryV2Name" "$noSuffix")"
      echo "##vso[task.setvariable variable=aiFoundryV2ProjectExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.CognitiveServices/accounts/projects" "$aiFoundryV2ProjectName" "$noSuffix")"

      echo "##vso[task.setvariable variable=databricksExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Azure.Databricks/workspaces" "$databricksName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=logicAppsExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Web/sites" "$logicAppsName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=eventHubsExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.EventHub/namespaces" "$eventHubsName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=dataFactoryExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.DataFactory/factories" "$dataFactoryName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=botServiceExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.BotService/botServices" "$botServiceName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=aksExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.ContainerService/managedClusters" "$aksName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=amlExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.MachineLearningServices/workspaces" "$amlName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=openaiExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.CognitiveServices/accounts" "$openaiName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=aiSearchExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Search/searchServices" "$safeNameAISearch" "$suffixStandardNoDash")"
      echo "##vso[task.setvariable variable=dashboardInsightsExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Insights/components" "$dashboardInsightsName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=applicationInsightExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Insights/components" "$applicationInsightName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=aiServicesExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.CognitiveServices/accounts" "$aiServicesPrefix" "$suffixStandardNoDash")"
      echo "##vso[task.setvariable variable=bingExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.CognitiveServices/accounts" "$bingName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=containerAppsEnvExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.App/managedEnvironments" "$containerAppsEnvName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=containerAppAExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.App/containerApps" "$containerAppAName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=containerAppWExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.App/containerApps" "$containerAppWName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=cosmosDBExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.DocumentDB/databaseAccounts" "$cosmosDBName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=functionAppExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Web/sites" "$functionAppName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=webAppExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Web/sites" "$webAppName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=funcAppServicePlanExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Web/serverfarms" "$funcAppServicePlanName" "$suffixAppServicePlan")"
      echo "##vso[task.setvariable variable=webAppServicePlanExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Web/serverfarms" "$webbAppServicePlanName" "$suffixAppServicePlan")"
      echo "##vso[task.setvariable variable=keyvaultExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.KeyVault/vaults" "$keyvaultName" "$suffixKeyvault")"
      echo "##vso[task.setvariable variable=miACAExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.ManagedIdentity/userAssignedIdentities" "$miACAPrefix" "$suffixStandard")"
      
      # Debug output for managed identity check
      echo "=== DEBUGGING MANAGED IDENTITY CHECK ==="
      echo "Target Resource Group: $targetResourceGroup"
      echo "MI Project Prefix: $miPrjPrefix"
      echo "Suffix Standard: $suffixStandard"
      echo "Looking for managed identity with prefix: $miPrjPrefix"
      
      # List all managed identities in the resource group for debugging
      echo "=== ALL MANAGED IDENTITIES IN RESOURCE GROUP ==="
      az resource list --resource-group "$targetResourceGroup" --resource-type "Microsoft.ManagedIdentity/userAssignedIdentities" --query "[].name" -o table || echo "Failed to list managed identities or none found"
      
      echo "##vso[task.setvariable variable=miPrjExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.ManagedIdentity/userAssignedIdentities" "$miPrjPrefix" "$suffixStandard")"
      echo "##vso[task.setvariable variable=storageAccount1001Exists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Storage/storageAccounts" "$storageAccount1001Name" "$suffixStorage1")"
      echo "##vso[task.setvariable variable=storageAccount2001Exists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Storage/storageAccounts" "$storageAccount2001Name" "$suffixStorage2")"
      echo "##vso[task.setvariable variable=aifExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.MachineLearningServices/workspaces" "$aifName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=redisExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Cache/Redis" "$redisName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=postgreSQLExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.DBforPostgreSQL/flexibleServers" "$postgreSQLName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=sqlServerExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Sql/servers" "$sqlServerName" "$suffixStandard")"
      echo "##vso[task.setvariable variable=sqlDBExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Sql/servers/databases" "$sqlDBName" "*")"
      echo "##vso[task.setvariable variable=acrProjectExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.ContainerRegistry/registries" "$acrProjectName" "$suffixAcr")"
      echo "##vso[task.setvariable variable=vmExists]$(resource_exists_fuzzy "$targetResourceGroup" "Microsoft.Compute/virtualMachines" "$vmName" "$suffixStandard")"

      # Print variables for debugging
      echo "Target Resource Group: $targetResourceGroup"
      echo "Key Vault Name: $keyvaultName"
- task: AzureCLI@2
  displayName: '05b_Extract_and_set_aifactory_salt_values'
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
      set -e
      
      az account set --subscription "$(dev_test_prod_sub_id)"
      
      DETERMINISTIC_SALT=""
      RANDOM_SALT=""
      
      echo "=== Starting aifactory salt extraction ==="
      
      # Build resource group names
      COMMON_RG_INPUT="$(commonResourceGroup_param)"
      if [ -n "$COMMON_RG_INPUT" ] && [ "$COMMON_RG_INPUT" != '$''(commonResourceGroup_param)' ]; then
        COMMON_RG="$COMMON_RG_INPUT"
      else
        COMMON_RG="$(admin_aifactoryPrefixRG)$(vnetResourceGroupBase)-$(admin_locationSuffix)-$(dev_test_prod)$(admin_aifactorySuffixRG)"
      fi
      
      echo "Common resource group: $COMMON_RG"
      
      # Try to extract deterministic salt from common resources
      echo "Scanning common RG for salt pattern..."
      RESOURCE_NAMES=$(az resource list --resource-group "$COMMON_RG" --query "[].name" -o tsv 2>/dev/null || echo "")
      
      if [ -n "$RESOURCE_NAMES" ]; then
        # Look for pattern like: anything-xxxxx-anything where xxxxx is 5 alphanumeric chars
        while IFS= read -r resource_name; do
          if [ -z "$resource_name" ]; then
            continue
          fi
          
          # Extract 5-char segments between hyphens
          IFS='-' read -ra PARTS <<< "$resource_name"
          for part in "${PARTS[@]}"; do
            if [ ${#part} -eq 5 ]; then
              # Check if it's alphanumeric lowercase
              if echo "$part" | grep -qE '^[a-z0-9]{5}$'; then
                DETERMINISTIC_SALT="$part"
                echo "Found deterministic salt from common RG: $DETERMINISTIC_SALT"
                break 2
              fi
            fi
          done
        done <<< "$RESOURCE_NAMES"
      else
        echo "Warning: Could not list resources in common RG"
      fi
      
      # Extract salts from managed identity if it exists
      MI_EXISTS="$(miPrjExists)"
      echo "miPrjExists: $MI_EXISTS"
      
      if [ "$MI_EXISTS" = "true" ]; then
        echo "Extracting salts from managed identity..."
        
        # Build project resource group name
        PROJECT_NUM="$(project_number_000)"
        PROJECT_NAME="prj${PROJECT_NUM}"
        LOCATION_SUFFIX="$(admin_locationSuffix)"
        ENV_NAME="$(dev_test_prod)"
        AIF_SUFFIX="$(admin_aifactorySuffixRG)"
        PROJECT_PREFIX="$(projectPrefix)"
        PROJECT_SUFFIX="$(projectSuffix)"
        COMMON_PREFIX="$(admin_aifactoryPrefixRG)"
        
        PROJECT_NAME_REPLACED="${PROJECT_NAME/prj/project}"
        PROJECT_RG="${COMMON_PREFIX}${PROJECT_PREFIX}${PROJECT_NAME_REPLACED}-${LOCATION_SUFFIX}-${ENV_NAME}${AIF_SUFFIX}${PROJECT_SUFFIX}"
        
        MI_PREFIX="mi-${PROJECT_NAME}-${LOCATION_SUFFIX}-${ENV_NAME}"
        
        echo "Looking for MI with prefix: $MI_PREFIX"
        echo "In resource group: $PROJECT_RG"
        
        MI_NAME=$(az resource list \
          --resource-group "$PROJECT_RG" \
          --resource-type "Microsoft.ManagedIdentity/userAssignedIdentities" \
          --query "[?starts_with(name, '$MI_PREFIX')].name" \
          -o tsv 2>/dev/null | head -n 1)
        
        if [ -n "$MI_NAME" ]; then
          echo "Found managed identity: $MI_NAME"
          
          # Extract the last segment before the final suffix
          # Expected format: mi-prj001-weu-dev-xxxxxxxxxxxxx-001
          # Remove the last segment (suffix like -001)
          MI_NO_SUFFIX="${MI_NAME%-*}"
          # Get the last remaining segment (the salt)
          SALT_SEGMENT="${MI_NO_SUFFIX##*-}"
          
          echo "Extracted salt segment: $SALT_SEGMENT (length: ${#SALT_SEGMENT})"
          
          # Expected format: 5 chars deterministic + 10 chars random = 15 total
          SALT_LEN=${#SALT_SEGMENT}
          if [ "$SALT_LEN" -ge 15 ]; then
            # Extract first 5 chars for deterministic salt (if not already found)
            if [ -z "$DETERMINISTIC_SALT" ]; then
              DETERMINISTIC_SALT="${SALT_SEGMENT:0:5}"
              echo "Extracted deterministic salt from MI: $DETERMINISTIC_SALT"
            fi
            # Extract next 10 chars for random salt
            RANDOM_SALT="${SALT_SEGMENT:5:10}"
            echo "Extracted random salt from MI: $RANDOM_SALT"
          elif [ "$SALT_LEN" -ge 5 ]; then
            echo "Warning: Salt segment shorter than expected (${SALT_LEN} chars)"
            if [ -z "$DETERMINISTIC_SALT" ]; then
              DETERMINISTIC_SALT="${SALT_SEGMENT:0:5}"
              echo "Extracted deterministic salt from MI: $DETERMINISTIC_SALT"
            fi
            # Try to extract whatever random portion is available
            if [ "$SALT_LEN" -gt 5 ]; then
              REMAINING=$((SALT_LEN - 5))
              RANDOM_SALT="${SALT_SEGMENT:5:$REMAINING}"
              echo "Extracted partial random salt from MI: $RANDOM_SALT"
            fi
          else
            echo "Warning: Salt segment too short (${SALT_LEN} chars, expected at least 5)"
          fi
        else
          echo "Warning: Could not find managed identity with prefix: $MI_PREFIX"
        fi
      else
        echo "Managed identity does not exist yet, skipping MI-based extraction"
      fi
      
      # Set the pipeline variables
      echo "##vso[task.setvariable variable=aifactory_salt]$DETERMINISTIC_SALT"
      echo "##vso[task.setvariable variable=aifactory_salt_random]$RANDOM_SALT"
      
      echo "=== Salt extraction complete ==="
      echo "aifactory_salt: ${DETERMINISTIC_SALT:-<not set>}"
      echo "aifactory_salt_random: ${RANDOM_SALT:-<not set>}"
      
      if [ -z "$DETERMINISTIC_SALT" ]; then
        echo "WARNING: aifactory_salt could not be determined"
      fi
      if [ -z "$RANDOM_SALT" ]; then
        echo "WARNING: aifactory_salt_random could not be determined"
      fi
- task: AzureCLI@2
  displayName: '05c_Validate Required Parameters'
  condition: ne(variables['debug_disable_validation_tasks'], 'true')
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
      #!/bin/bash
      
      # List of required variables with their Azure DevOps variable references
      declare -A required_vars=(
        ["aiHubExists"]="$(aiHubExists)"
        ["aifProjectExists"]="$(aifProjectExists)"
        ["aiFoundryV2Exists"]="$(aiFoundryV2Exists)"
        ["aiFoundryV2ProjectExists"]="$(aiFoundryV2ProjectExists)"
        ["amlExists"]="$(amlExists)"
        ["datafactoryExists"]="$(datafactoryExists)"
        ["logicAppsExists"]="$(logicAppsExists)"
        ["databricksExists"]="$(databricksExists)"
        ["aksExists"]="$(aksExists)"
        ["openaiExists"]="$(openaiExists)"
        ["eventHubsExists"]="$(eventHubsExists)"
        ["aiSearchExists"]="$(aiSearchExists)"
        ["dashboardInsightsExists"]="$(dashboardInsightsExists)"
        ["applicationInsightExists"]="$(applicationInsightExists)"
        ["aiServicesExists"]="$(aiServicesExists)"
        ["bingExists"]="$(bingExists)"
        ["containerAppsEnvExists"]="$(containerAppsEnvExists)"
        ["containerAppWExists"]="$(containerAppWExists)"
        ["cosmosDBExists"]="$(cosmosDBExists)"
        ["functionAppExists"]="$(functionAppExists)"
        ["webAppExists"]="$(webAppExists)"
        ["botServiceExists"]="$(botServiceExists)"
        ["funcAppServicePlanExists"]="$(funcAppServicePlanExists)"
        ["webAppServicePlanExists"]="$(webAppServicePlanExists)"
        ["keyvaultExists"]="$(keyvaultExists)"
        ["miACAExists"]="$(miACAExists)"
        ["miPrjExists"]="$(miPrjExists)"
        ["storageAccount1001Exists"]="$(storageAccount1001Exists)"
        ["storageAccount2001Exists"]="$(storageAccount2001Exists)"
        ["aifExists"]="$(aifExists)"
        ["redisExists"]="$(redisExists)"
        ["postgreSQLExists"]="$(postgreSQLExists)"
        ["sqlServerExists"]="$(sqlServerExists)"
        ["sqlDBExists"]="$(sqlDBExists)"
        ["acrProjectExists"]="$(acrProjectExists)"
        ["vmExists"]="$(vmExists)"
        ["zoneazurecontainerappsExists"]="$(zoneazurecontainerappsExists)"
        ["zoneredisExists"]="$(zoneredisExists)"
        ["zonepostgresExists"]="$(zonepostgresExists)"
        ["zonesqlExists"]="$(zonesqlExists)"
        ["zoneMongoExists"]="$(zoneMongoExists)"
        ["zoneServicesAiExists"]="$(zoneServicesAiExists)"
        ["zoneAPIMExists"]="$(zoneAPIMExists)"
        ["aifactory_salt_random"]="$(aifactory_salt_random)"
      )

      # Validate each variable
      for var_name in "${!required_vars[@]}"; do
        value="${required_vars[$var_name]}"
        echo "Checking variable: $var_name, Value: $value"
        if [ -z "$value" ] || [ "$value" = "\$(${var_name})" ]; then
          if [ "$var_name" = "aifactory_salt_random" ]; then
            echo "Warning: Variable $var_name is not set or empty  (It should be 10 characters), but continuing execution. aifactory_salt_random needs to be set if UPDATING an existing project - adding services. But not att init."
          else
            echo "Warning: Required variable $var_name is not set or empty."
            exit 0
          fi
        fi
      done

      echo "All required parameters are set and valid."
- task: AzureCLI@2
  displayName: '04_Delete_Service_If_Not_Enabled_And_Exists'
  condition: and(succeeded(), eq(variables['enableDeleteForDisabledResources'], 'true'))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
      set -e
      
      az account set --subscription "$(dev_test_prod_sub_id)"
      
      echo "=== Delete Services If Not Enabled (Complete Mode) ==="
      
      # Build resource group name
      commonRGNamePrefix="$(admin_aifactoryPrefixRG)"
      projectNumber="$(project_number_000)"
      projectName="prj${projectNumber}"
      locationSuffix="$(admin_locationSuffix)"
      envName="$(dev_test_prod)"
      aifactorySuffixRG="$(admin_aifactorySuffixRG)"
      projectPrefix="$(projectPrefix)"
      projectSuffix="$(projectSuffix)"
      
      projectNameReplaced="${projectName/prj/project}"
      projectResourceGroup="${commonRGNamePrefix}${projectPrefix}${projectNameReplaced}-${locationSuffix}-${envName}${aifactorySuffixRG}${projectSuffix}"
      
      echo "Target resource group: $projectResourceGroup"
      
      # Check networking mode to determine if private endpoints are expected
      allowPublic="$(allowPublicAccessWhenBehindVnet)"
      enablePublicGenAI="$(enablePublicGenAIAccess)"
      enablePublicPerimeter="$(enablePublicAccessWithPerimeter)"
      
      echo "Networking configuration:"
      echo "  allowPublicAccessWhenBehindVnet: $allowPublic"
      echo "  enablePublicGenAIAccess: $enablePublicGenAI"
      echo "  enablePublicAccessWithPerimeter: $enablePublicPerimeter"
      
      # Determine if private endpoints are expected
      # No private endpoints: true, true, true
      # Has private endpoints: false, false, false OR false, false, true
      if [ "$allowPublic" = "true" ] && [ "$enablePublicGenAI" = "true" ] && [ "$enablePublicPerimeter" = "true" ]; then
        expect_private_endpoints=false
        echo "Networking mode: Public access (no private endpoints expected)"
      else
        expect_private_endpoints=true
        echo "Networking mode: Private networking (private endpoints expected)"
      fi
      
      # Function to delete private endpoints for a resource
      delete_private_endpoints() {
        local resource_name="$1"
        local resource_type="$2"
        
        echo "Searching for private endpoints for $resource_type: $resource_name"
        
        # Find private endpoints matching pattern: resourcename-pend or resourcename-pend-*
        pend_list=$(az network private-endpoint list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${resource_name}-pend')].name" \
          -o tsv 2>/dev/null || echo "")
        
        if [ -n "$pend_list" ]; then
          while IFS= read -r pend_name; do
            if [ -n "$pend_name" ]; then
              echo "  Deleting private endpoint: $pend_name"
              az network private-endpoint delete \
                --resource-group "$projectResourceGroup" \
                --name "$pend_name" \
                --yes 2>&1 || echo "  Warning: Failed to delete private endpoint $pend_name"
            fi
          done <<< "$pend_list"
        else
          echo "  No private endpoints found for $resource_name"
        fi
        
        # Also check for NICs with pattern: resourcename-pend-nic or resourcename-pend-*-nic
        nic_list=$(az network nic list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${resource_name}-pend')].name" \
          -o tsv 2>/dev/null || echo "")
        
        if [ -n "$nic_list" ]; then
          while IFS= read -r nic_name; do
            if [ -n "$nic_name" ]; then
              echo "  Deleting NIC: $nic_name"
              az network nic delete \
                --resource-group "$projectResourceGroup" \
                --name "$nic_name" 2>&1 || echo "  Warning: Failed to delete NIC $nic_name"
            fi
          done <<< "$nic_list"
        fi
      }
      
      # Function to delete storage account private endpoints
      delete_storage_private_endpoints() {
        local storage_name="$1"
        
        echo "Searching for storage private endpoints for: $storage_name"
        
        # Storage has special naming: storagename-file-pend, storagename-blob-pend, etc.
        storage_pend_patterns=(
          "${storage_name}-file-pend"
          "${storage_name}-blob-pend"
          "${storage_name}-queue-pend"
          "${storage_name}-table-pend"
        )
        
        for pattern in "${storage_pend_patterns[@]}"; do
          # Find exact match or with suffix
          pend_list=$(az network private-endpoint list \
            --resource-group "$projectResourceGroup" \
            --query "[?starts_with(name, '${pattern}')].name" \
            -o tsv 2>/dev/null || echo "")
          
          if [ -n "$pend_list" ]; then
            while IFS= read -r pend_name; do
              if [ -n "$pend_name" ]; then
                echo "  Deleting storage private endpoint: $pend_name"
                az network private-endpoint delete \
                  --resource-group "$projectResourceGroup" \
                  --name "$pend_name" \
                  --yes 2>&1 || echo "  Warning: Failed to delete $pend_name"
              fi
            done <<< "$pend_list"
          fi
          
          # Also clean up NICs
          nic_list=$(az network nic list \
            --resource-group "$projectResourceGroup" \
            --query "[?starts_with(name, '${pattern}')].name" \
            -o tsv 2>/dev/null || echo "")
          
          if [ -n "$nic_list" ]; then
            while IFS= read -r nic_name; do
              if [ -n "$nic_name" ]; then
                echo "  Deleting storage NIC: $nic_name"
                az network nic delete \
                  --resource-group "$projectResourceGroup" \
                  --name "$nic_name" 2>&1 || echo "  Warning: Failed to delete $nic_name"
              fi
            done <<< "$nic_list"
          fi
        done
      }
      
      # =============================================================================
      # AI SEARCH - Delete if disabled and exists
      # =============================================================================
      enableAISearch="$(enableAISearch)"
      aiSearchExists="$(aiSearchExists)"
      addAISearch="$(addAISearch)"
      enableAFoundryCaphost="$(enableAFoundryCaphost)"
      enableAIFoundry="$(enableAIFoundry)"
      
      echo ""
      echo "--- AI Search ---"
      echo "enableAISearch: $enableAISearch"
      echo "aiSearchExists: $aiSearchExists"
      echo "addAISearch: $addAISearch"
      echo "enableAFoundryCaphost: $enableAFoundryCaphost"
      echo "enableAIFoundry: $enableAIFoundry"
      
      # Check if AI Search is a dependency for Foundry with capability host
      if [ "$enableAFoundryCaphost" = "true" ] && [ "$enableAIFoundry" = "true" ]; then
        echo "üîí AI Search is required as dependency for AI Foundry with capability host - skipping deletion"
        skip_aisearch_deletion=true
      else
        skip_aisearch_deletion=false
      fi
      
      if [ "$skip_aisearch_deletion" = "false" ] && [ "$enableAISearch" = "false" ] && [ "$addAISearch" = "false" ] && [ "$aiSearchExists" = "true" ]; then
        echo "‚úì AI Search is disabled but exists - proceeding with deletion"
        
        # Find AI Search resource
        safeNameAISearch="aisearch${projectName}${locationSuffix}${envName}"
        
        # Find with fuzzy matching
        aisearch_name=$(az search service list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${safeNameAISearch}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$aisearch_name" ]; then
          echo "Found AI Search service: $aisearch_name"
          
          # STEP 1: Delete AI Search shared private endpoints (special for AI Search)
          echo "Deleting AI Search shared private endpoints..."
          
          # Pattern 1: {aisearch_name}-shared-pe-0, {aisearch_name}-shared-pe-1
          shared_pe_list=$(az search shared-private-link-resource list \
            --resource-group "$projectResourceGroup" \
            --service-name "$aisearch_name" \
            --query "[].name" \
            -o tsv 2>/dev/null || echo "")
          
          if [ -n "$shared_pe_list" ]; then
            echo "  Found shared private endpoints for AI Search:"
            while IFS= read -r shared_pe_name; do
              if [ -n "$shared_pe_name" ]; then
                echo "    - $shared_pe_name"
                echo "    Deleting shared private endpoint: $shared_pe_name"
                az search shared-private-link-resource delete \
                  --resource-group "$projectResourceGroup" \
                  --service-name "$aisearch_name" \
                  --name "$shared_pe_name" \
                  --yes 2>&1 || echo "    Warning: Failed to delete $shared_pe_name"
                
                # Wait a bit for deletion to propagate
                sleep 5
              fi
            done <<< "$shared_pe_list"
            
            # Wait for shared private endpoints to be fully deleted
            echo "  Waiting for shared private endpoints deletion to complete..."
            sleep 10
          else
            echo "  No shared private endpoints found via Azure CLI"
          fi
          
          # Also try to find and delete using naming patterns (fallback method)
          echo "  Checking for shared private endpoints using naming patterns..."
          
          # Delete pattern: {aisearch_name}-shared-pe-*
          for i in 0 1 2 3; do
            shared_pe_pattern="${aisearch_name}-shared-pe-${i}"
            echo "    Checking for: $shared_pe_pattern"
            
            az search shared-private-link-resource delete \
              --resource-group "$projectResourceGroup" \
              --service-name "$aisearch_name" \
              --name "$shared_pe_pattern" \
              --yes 2>/dev/null && echo "    ‚úì Deleted $shared_pe_pattern" || true
          done
          
          # Delete common foundry-related shared endpoints
          foundry_shared_endpoints=(
            "shared-pe-foundry-openai"
            "shared-pe-foundry-cogsvc"
          )
          
          for shared_pe_name in "${foundry_shared_endpoints[@]}"; do
            echo "    Checking for: $shared_pe_name"
            az search shared-private-link-resource delete \
              --resource-group "$projectResourceGroup" \
              --service-name "$aisearch_name" \
              --name "$shared_pe_name" \
              --yes 2>/dev/null && echo "    ‚úì Deleted $shared_pe_name" || true
          done
          
          echo "  Shared private endpoints deletion completed"
          
          # STEP 2: Delete regular private endpoints if they exist (based on networking mode)
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$aisearch_name" "AI Search"
          fi
          
          # STEP 3: Delete the AI Search service
          echo "Deleting AI Search service: $aisearch_name"
          az search service delete \
            --resource-group "$projectResourceGroup" \
            --name "$aisearch_name" \
            --yes 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted AI Search service"
            echo "##vso[task.setvariable variable=aiSearchExists]false"
          else
            echo "‚ùå Failed to delete AI Search service"
          fi
        else
          echo "‚ö†Ô∏è  AI Search service not found with prefix: $safeNameAISearch"
        fi
      elif [ "$skip_aisearch_deletion" = "true" ]; then
        echo "‚ÑπÔ∏è  AI Search deletion skipped - required for AI Foundry with capability host"
      elif [ "$enableAISearch" = "true" ]; then
        echo "‚ÑπÔ∏è  AI Search is enabled - skipping deletion"
      elif [ "$aiSearchExists" = "false" ]; then
        echo "‚ÑπÔ∏è  AI Search doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for AI Search deletion"
      fi
      
      # =============================================================================
      # COSMOS DB - Delete if disabled and exists (Capability host dependency)
      # =============================================================================
      enableCosmosDB="$(enableCosmosDB)"
      cosmosDBExists="$(cosmosDBExists)"
      
      echo ""
      echo "--- Cosmos DB ---"
      echo "enableCosmosDB: $enableCosmosDB"
      echo "cosmosDBExists: $cosmosDBExists"
      
      # Check if Cosmos DB is a dependency for Foundry with capability host
      if [ "$enableAFoundryCaphost" = "true" ] && [ "$enableAIFoundry" = "true" ]; then
        echo "üîí Cosmos DB is required as dependency for AI Foundry with capability host - skipping deletion"
        skip_cosmosdb_deletion=true
      else
        skip_cosmosdb_deletion=false
      fi
      
      if [ "$skip_cosmosdb_deletion" = "false" ] && [ "$enableCosmosDB" = "false" ] && [ "$cosmosDBExists" = "true" ]; then
        echo "‚úì Cosmos DB is disabled but exists - proceeding with deletion"
        
        cosmosDBName="cosmos-${projectName}-${locationSuffix}-${envName}"
        
        cosmosdb_name=$(az cosmosdb list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${cosmosDBName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$cosmosdb_name" ]; then
          echo "Found Cosmos DB: $cosmosdb_name"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$cosmosdb_name" "Cosmos DB"
          fi
          
          echo "Deleting Cosmos DB: $cosmosdb_name"
          az cosmosdb delete \
            --resource-group "$projectResourceGroup" \
            --name "$cosmosdb_name" \
            --yes 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted Cosmos DB"
            echo "##vso[task.setvariable variable=cosmosDBExists]false"
          else
            echo "‚ùå Failed to delete Cosmos DB"
          fi
        else
          echo "‚ö†Ô∏è  Cosmos DB not found with prefix: $cosmosDBName"
        fi
      elif [ "$skip_cosmosdb_deletion" = "true" ]; then
        echo "‚ÑπÔ∏è  Cosmos DB deletion skipped - required for AI Foundry with capability host"
      elif [ "$enableCosmosDB" = "true" ]; then
        echo "‚ÑπÔ∏è  Cosmos DB is enabled - skipping deletion"
      elif [ "$cosmosDBExists" = "false" ]; then
        echo "‚ÑπÔ∏è  Cosmos DB doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Cosmos DB deletion"
      fi
      
      # =============================================================================
      # WEB APP - Delete if disabled and exists
      # =============================================================================
      enableWebApp="$(enableWebApp)"
      webAppExists="$(webAppExists)"
      
      echo ""
      echo "--- Web App ---"
      echo "enableWebApp: $enableWebApp"
      echo "webAppExists: $webAppExists"
      
      if [ "$enableWebApp" = "false" ] && [ "$webAppExists" = "true" ]; then
        echo "‚úì Web App is disabled but exists - proceeding with deletion"
        
        webAppName="webapp-${projectName}-${locationSuffix}-${envName}"
        
        webapp_name=$(az webapp list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${webAppName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$webapp_name" ]; then
          echo "Found Web App: $webapp_name"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$webapp_name" "Web App"
          fi
          
          echo "Deleting Web App: $webapp_name"
          az webapp delete \
            --resource-group "$projectResourceGroup" \
            --name "$webapp_name" 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted Web App"
            echo "##vso[task.setvariable variable=webAppExists]false"
          else
            echo "‚ùå Failed to delete Web App"
          fi
        else
          echo "‚ö†Ô∏è  Web App not found with prefix: $webAppName"
        fi
      elif [ "$enableWebApp" = "true" ]; then
        echo "‚ÑπÔ∏è  Web App is enabled - skipping deletion"
      elif [ "$webAppExists" = "false" ]; then
        echo "‚ÑπÔ∏è  Web App doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Web App deletion"
      fi
      
      # =============================================================================
      # FUNCTION APP - Delete if disabled and exists
      # =============================================================================
      enableFunction="$(enableFunction)"
      functionAppExists="$(functionAppExists)"
      
      echo ""
      echo "--- Function App ---"
      echo "enableFunction: $enableFunction"
      echo "functionAppExists: $functionAppExists"
      
      if [ "$enableFunction" = "false" ] && [ "$functionAppExists" = "true" ]; then
        echo "‚úì Function App is disabled but exists - proceeding with deletion"
        
        functionAppName="func-${projectName}-${locationSuffix}-${envName}"
        
        func_name=$(az functionapp list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${functionAppName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$func_name" ]; then
          echo "Found Function App: $func_name"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$func_name" "Function App"
          fi
          
          echo "Deleting Function App: $func_name"
          az functionapp delete \
            --resource-group "$projectResourceGroup" \
            --name "$func_name" 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted Function App"
            echo "##vso[task.setvariable variable=functionAppExists]false"
          else
            echo "‚ùå Failed to delete Function App"
          fi
        else
          echo "‚ö†Ô∏è  Function App not found with prefix: $functionAppName"
        fi
      elif [ "$enableFunction" = "true" ]; then
        echo "‚ÑπÔ∏è  Function App is enabled - skipping deletion"
      elif [ "$functionAppExists" = "false" ]; then
        echo "‚ÑπÔ∏è  Function App doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Function App deletion"
      fi
      
      # =============================================================================
      # CONTAINER APPS - Delete if disabled and exists
      # =============================================================================
      enableContainerApps="$(enableContainerApps)"
      containerAppAExists="$(containerAppAExists)"
      containerAppWExists="$(containerAppWExists)"
      
      echo ""
      echo "--- Container Apps ---"
      echo "enableContainerApps: $enableContainerApps"
      echo "containerAppAExists: $containerAppAExists"
      echo "containerAppWExists: $containerAppWExists"
      
      if [ "$enableContainerApps" = "false" ]; then
        # Delete Container App A
        if [ "$containerAppAExists" = "true" ]; then
          echo "‚úì Container App A is disabled but exists - proceeding with deletion"
          
          containerAppAName="aca-a-${projectName}${locationSuffix}${envName}"
          
          aca_a_name=$(az containerapp list \
            --resource-group "$projectResourceGroup" \
            --query "[?starts_with(name, '${containerAppAName}')].name" \
            -o tsv | head -n1)
          
          if [ -n "$aca_a_name" ]; then
            echo "Found Container App A: $aca_a_name"
            
            echo "Deleting Container App A: $aca_a_name"
            az containerapp delete \
              --resource-group "$projectResourceGroup" \
              --name "$aca_a_name" \
              --yes 2>&1
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Successfully deleted Container App A"
              echo "##vso[task.setvariable variable=containerAppAExists]false"
            else
              echo "‚ùå Failed to delete Container App A"
            fi
          fi
        fi
        
        # Delete Container App W
        if [ "$containerAppWExists" = "true" ]; then
          echo "‚úì Container App W is disabled but exists - proceeding with deletion"
          
          containerAppWName="aca-w-${projectName}${locationSuffix}${envName}"
          
          aca_w_name=$(az containerapp list \
            --resource-group "$projectResourceGroup" \
            --query "[?starts_with(name, '${containerAppWName}')].name" \
            -o tsv | head -n1)
          
          if [ -n "$aca_w_name" ]; then
            echo "Found Container App W: $aca_w_name"
            
            echo "Deleting Container App W: $aca_w_name"
            az containerapp delete \
              --resource-group "$projectResourceGroup" \
              --name "$aca_w_name" \
              --yes 2>&1
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Successfully deleted Container App W"
              echo "##vso[task.setvariable variable=containerAppWExists]false"
            else
              echo "‚ùå Failed to delete Container App W"
            fi
          fi
        fi
      elif [ "$enableContainerApps" = "true" ]; then
        echo "‚ÑπÔ∏è  Container Apps are enabled - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Container Apps don't exist - skipping deletion"
      fi
      
      # =============================================================================
      # LOGIC APPS - Delete if disabled and exists
      # =============================================================================
      enableLogicApps="$(enableLogicApps)"
      logicAppsExists="$(logicAppsExists)"
      
      echo ""
      echo "--- Logic Apps ---"
      echo "enableLogicApps: $enableLogicApps"
      echo "logicAppsExists: $logicAppsExists"
      
      if [ "$enableLogicApps" = "false" ] && [ "$logicAppsExists" = "true" ]; then
        echo "‚úì Logic Apps is disabled but exists - proceeding with deletion"
        
        logicAppName="logic-${projectName}-${locationSuffix}-${envName}"
        
        logic_name=$(az resource list \
          --resource-group "$projectResourceGroup" \
          --resource-type "Microsoft.Logic/workflows" \
          --query "[?starts_with(name, '${logicAppName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$logic_name" ]; then
          echo "Found Logic App: $logic_name"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$logic_name" "Logic App"
          fi
          
          echo "Deleting Logic App: $logic_name"
          az logic workflow delete \
            --resource-group "$projectResourceGroup" \
            --name "$logic_name" \
            --yes 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted Logic App"
            echo "##vso[task.setvariable variable=logicAppsExists]false"
          else
            echo "‚ùå Failed to delete Logic App"
          fi
        else
          echo "‚ö†Ô∏è  Logic App not found with prefix: $logicAppName"
        fi
      elif [ "$enableLogicApps" = "true" ]; then
        echo "‚ÑπÔ∏è  Logic Apps is enabled - skipping deletion"
      elif [ "$logicAppsExists" = "false" ]; then
        echo "‚ÑπÔ∏è  Logic Apps doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Logic Apps deletion"
      fi
      
      # =============================================================================
      # EVENT HUBS - Delete if disabled and exists
      # =============================================================================
      enableEventHubs="$(enableEventHubs)"
      eventHubsExists="$(eventHubsExists)"
      
      echo ""
      echo "--- Event Hubs ---"
      echo "enableEventHubs: $enableEventHubs"
      echo "eventHubsExists: $eventHubsExists"
      
      if [ "$enableEventHubs" = "false" ] && [ "$eventHubsExists" = "true" ]; then
        echo "‚úì Event Hubs is disabled but exists - proceeding with deletion"
        
        eventHubName="eh-${projectNumber}-${locationSuffix}-${envName}"
        
        eh_name=$(az eventhubs namespace list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${eventHubName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$eh_name" ]; then
          echo "Found Event Hub: $eh_name"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$eh_name" "Event Hub"
          fi
          
          echo "Deleting Event Hub: $eh_name"
          az eventhubs namespace delete \
            --resource-group "$projectResourceGroup" \
            --name "$eh_name" 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted Event Hub"
            echo "##vso[task.setvariable variable=eventHubsExists]false"
          else
            echo "‚ùå Failed to delete Event Hub"
          fi
        else
          echo "‚ö†Ô∏è  Event Hub not found with prefix: $eventHubName"
        fi
      elif [ "$enableEventHubs" = "true" ]; then
        echo "‚ÑπÔ∏è  Event Hubs is enabled - skipping deletion"
      elif [ "$eventHubsExists" = "false" ]; then
        echo "‚ÑπÔ∏è  Event Hubs doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Event Hubs deletion"
      fi
      
      # =============================================================================
      # POSTGRESQL - Delete if disabled and exists
      # =============================================================================
      enablePostgreSQL="$(enablePostgreSQL)"
      postgreSQLExists="$(postgreSQLExists)"
      
      echo ""
      echo "--- PostgreSQL ---"
      echo "enablePostgreSQL: $enablePostgreSQL"
      echo "postgreSQLExists: $postgreSQLExists"
      
      if [ "$enablePostgreSQL" = "false" ] && [ "$postgreSQLExists" = "true" ]; then
        echo "‚úì PostgreSQL is disabled but exists - proceeding with deletion"
        
        postgresName="pg-flex-${projectName}-${locationSuffix}-${envName}"
        
        pg_name=$(az postgres flexible-server list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${postgresName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$pg_name" ]; then
          echo "Found PostgreSQL: $pg_name"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$pg_name" "PostgreSQL"
          fi
          
          echo "Deleting PostgreSQL: $pg_name"
          az postgres flexible-server delete \
            --resource-group "$projectResourceGroup" \
            --name "$pg_name" \
            --yes 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted PostgreSQL"
            echo "##vso[task.setvariable variable=postgreSQLExists]false"
          else
            echo "‚ùå Failed to delete PostgreSQL"
          fi
        else
          echo "‚ö†Ô∏è  PostgreSQL not found with prefix: $postgresName"
        fi
      elif [ "$enablePostgreSQL" = "true" ]; then
        echo "‚ÑπÔ∏è  PostgreSQL is enabled - skipping deletion"
      elif [ "$postgreSQLExists" = "false" ]; then
        echo "‚ÑπÔ∏è  PostgreSQL doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for PostgreSQL deletion"
      fi
      
      # =============================================================================
      # REDIS CACHE - Delete if disabled and exists
      # =============================================================================
      enableRedisCache="$(enableRedisCache)"
      redisExists="$(redisExists)"
      
      echo ""
      echo "--- Redis Cache ---"
      echo "enableRedisCache: $enableRedisCache"
      echo "redisExists: $redisExists"
      
      if [ "$enableRedisCache" = "false" ] && [ "$redisExists" = "true" ]; then
        echo "‚úì Redis Cache is disabled but exists - proceeding with deletion"
        
        redisName="redis-${projectName}-${locationSuffix}-${envName}"
        
        redis_name=$(az redis list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${redisName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$redis_name" ]; then
          echo "Found Redis Cache: $redis_name"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$redis_name" "Redis Cache"
          fi
          
          echo "Deleting Redis Cache: $redis_name"
          az redis delete \
            --resource-group "$projectResourceGroup" \
            --name "$redis_name" \
            --yes 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted Redis Cache"
            echo "##vso[task.setvariable variable=redisExists]false"
          else
            echo "‚ùå Failed to delete Redis Cache"
          fi
        else
          echo "‚ö†Ô∏è  Redis Cache not found with prefix: $redisName"
        fi
      elif [ "$enableRedisCache" = "true" ]; then
        echo "‚ÑπÔ∏è  Redis Cache is enabled - skipping deletion"
      elif [ "$redisExists" = "false" ]; then
        echo "‚ÑπÔ∏è  Redis Cache doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Redis Cache deletion"
      fi
      
      # =============================================================================
      # SQL DATABASE - Delete if disabled and exists
      # =============================================================================
      enableSQLDatabase="$(enableSQLDatabase)"
      sqlServerExists="$(sqlServerExists)"
      sqlDBExists="$(sqlDBExists)"
      
      echo ""
      echo "--- SQL Database ---"
      echo "enableSQLDatabase: $enableSQLDatabase"
      echo "sqlServerExists: $sqlServerExists"
      echo "sqlDBExists: $sqlDBExists"
      
      if [ "$enableSQLDatabase" = "false" ] && [ "$sqlServerExists" = "true" ]; then
        echo "‚úì SQL Database is disabled but exists - proceeding with deletion"
        
        sqlServerName="sql-${projectName}-${locationSuffix}-${envName}"
        
        sql_server=$(az sql server list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${sqlServerName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$sql_server" ]; then
          echo "Found SQL Server: $sql_server"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$sql_server" "SQL Server"
          fi
          
          echo "Deleting SQL Server (and databases): $sql_server"
          az sql server delete \
            --resource-group "$projectResourceGroup" \
            --name "$sql_server" \
            --yes 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted SQL Server"
            echo "##vso[task.setvariable variable=sqlServerExists]false"
            echo "##vso[task.setvariable variable=sqlDBExists]false"
          else
            echo "‚ùå Failed to delete SQL Server"
          fi
        else
          echo "‚ö†Ô∏è  SQL Server not found with prefix: $sqlServerName"
        fi
      elif [ "$enableSQLDatabase" = "true" ]; then
        echo "‚ÑπÔ∏è  SQL Database is enabled - skipping deletion"
      elif [ "$sqlServerExists" = "false" ]; then
        echo "‚ÑπÔ∏è  SQL Server doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for SQL Database deletion"
      fi
      
      # =============================================================================
      # DATABRICKS - Delete if disabled and exists
      # =============================================================================
      enableDatabricks="$(enableDatabricks)"
      databricksExists="$(databricksExists)"
      
      echo ""
      echo "--- Databricks ---"
      echo "enableDatabricks: $enableDatabricks"
      echo "databricksExists: $databricksExists"
      
      if [ "$enableDatabricks" = "false" ] && [ "$databricksExists" = "true" ]; then
        echo "‚úì Databricks is disabled but exists - proceeding with deletion"
        
        databricksName="dbx-${projectNumber}-${locationSuffix}-${envName}"
        
        dbx_name=$(az databricks workspace list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${databricksName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$dbx_name" ]; then
          echo "Found Databricks: $dbx_name"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$dbx_name" "Databricks"
          fi
          
          echo "Deleting Databricks: $dbx_name"
          az databricks workspace delete \
            --resource-group "$projectResourceGroup" \
            --name "$dbx_name" \
            --yes 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted Databricks"
            echo "##vso[task.setvariable variable=databricksExists]false"
          else
            echo "‚ùå Failed to delete Databricks"
          fi
        else
          echo "‚ö†Ô∏è  Databricks not found with prefix: $databricksName"
        fi
      elif [ "$enableDatabricks" = "true" ]; then
        echo "‚ÑπÔ∏è  Databricks is enabled - skipping deletion"
      elif [ "$databricksExists" = "false" ]; then
        echo "‚ÑπÔ∏è  Databricks doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Databricks deletion"
      fi
      
      # =============================================================================
      # AZURE MACHINE LEARNING - Delete if disabled and exists
      # =============================================================================
      enableAzureMachineLearning="$(enableAzureMachineLearning)"
      amlExists="$(amlExists)"
      enableAksForAzureML="$(enableAksForAzureML)"
      aksExists="$(aksExists)"
      
      echo ""
      echo "--- Azure Machine Learning ---"
      echo "enableAzureMachineLearning: $enableAzureMachineLearning"
      echo "amlExists: $amlExists"
      echo "enableAksForAzureML: $enableAksForAzureML"
      echo "aksExists: $aksExists"
      
      if [ "$enableAzureMachineLearning" = "false" ] && [ "$amlExists" = "true" ]; then
        echo "‚úì Azure ML is disabled but exists - proceeding with deletion"
        
        amlName="aml-${projectNumber}-${locationSuffix}-${envName}"
        
        aml_name=$(az ml workspace list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${amlName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$aml_name" ]; then
          echo "Found Azure ML workspace: $aml_name"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$aml_name" "Azure ML"
          fi
          
          echo "Deleting Azure ML workspace: $aml_name"
          az ml workspace delete \
            --resource-group "$projectResourceGroup" \
            --name "$aml_name" \
            --yes 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted Azure ML workspace"
            echo "##vso[task.setvariable variable=amlExists]false"
          else
            echo "‚ùå Failed to delete Azure ML workspace"
          fi
        else
          echo "‚ö†Ô∏è  Azure ML workspace not found with prefix: $amlName"
        fi
      elif [ "$enableAzureMachineLearning" = "true" ]; then
        echo "‚ÑπÔ∏è  Azure Machine Learning is enabled - skipping deletion"
      elif [ "$amlExists" = "false" ]; then
        echo "‚ÑπÔ∏è  Azure ML doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Azure ML deletion"
      fi
      
      # Delete AKS if it's not needed for Azure ML
      if [ "$enableAksForAzureML" = "false" ] && [ "$aksExists" = "true" ]; then
        echo "‚úì AKS for Azure ML is disabled but exists - proceeding with deletion"
        
        aksName="aks${projectNumber}-${locationSuffix}-${envName}"
        
        aks_name=$(az aks list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${aksName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$aks_name" ]; then
          echo "Found AKS cluster: $aks_name"
          
          echo "Deleting AKS cluster: $aks_name"
          az aks delete \
            --resource-group "$projectResourceGroup" \
            --name "$aks_name" \
            --yes 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted AKS cluster"
            echo "##vso[task.setvariable variable=aksExists]false"
          else
            echo "‚ùå Failed to delete AKS cluster"
          fi
        else
          echo "‚ö†Ô∏è  AKS cluster not found with prefix: $aksName"
        fi
      fi
      
      # =============================================================================
      # DATA FACTORY - Delete if disabled and exists
      # =============================================================================
      enableDatafactory="$(enableDatafactory)"
      dataFactoryExists="$(dataFactoryExists)"
      
      echo ""
      echo "--- Data Factory ---"
      echo "enableDatafactory: $enableDatafactory"
      echo "dataFactoryExists: $dataFactoryExists"
      
      if [ "$enableDatafactory" = "false" ] && [ "$dataFactoryExists" = "true" ]; then
        echo "‚úì Data Factory is disabled but exists - proceeding with deletion"
        
        adfName="adf-${projectNumber}-${locationSuffix}-${envName}"
        
        adf_name=$(az datafactory list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${adfName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$adf_name" ]; then
          echo "Found Data Factory: $adf_name"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$adf_name" "Data Factory"
          fi
          
          echo "Deleting Data Factory: $adf_name"
          az datafactory delete \
            --resource-group "$projectResourceGroup" \
            --name "$adf_name" \
            --yes 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted Data Factory"
            echo "##vso[task.setvariable variable=dataFactoryExists]false"
          else
            echo "‚ùå Failed to delete Data Factory"
          fi
        else
          echo "‚ö†Ô∏è  Data Factory not found with prefix: $adfName"
        fi
      elif [ "$enableDatafactory" = "true" ]; then
        echo "‚ÑπÔ∏è  Data Factory is enabled - skipping deletion"
      elif [ "$dataFactoryExists" = "false" ]; then
        echo "‚ÑπÔ∏è  Data Factory doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Data Factory deletion"
      fi
      
      # =============================================================================
      # BING SEARCH - Delete if disabled and exists
      # =============================================================================
      enableBing="$(enableBing)"
      bingExists="$(bingExists)"
      
      echo ""
      echo "--- Bing Search ---"
      echo "enableBing: $enableBing"
      echo "bingExists: $bingExists"
      
      if [ "$enableBing" = "false" ] && [ "$bingExists" = "true" ]; then
        echo "‚úì Bing Search is disabled but exists - proceeding with deletion"
        
        bingName="bing-${projectName}-${locationSuffix}-${envName}"
        
        bing_name=$(az cognitiveservices account list \
          --resource-group "$projectResourceGroup" \
          --query "[?starts_with(name, '${bingName}')].name" \
          -o tsv | head -n1)
        
        if [ -n "$bing_name" ]; then
          echo "Found Bing Search: $bing_name"
          
          if [ "$expect_private_endpoints" = true ]; then
            delete_private_endpoints "$bing_name" "Bing Search"
          fi
          
          echo "Deleting Bing Search: $bing_name"
          az cognitiveservices account delete \
            --resource-group "$projectResourceGroup" \
            --name "$bing_name" 2>&1
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deleted Bing Search"
            echo "##vso[task.setvariable variable=bingExists]false"
          else
            echo "‚ùå Failed to delete Bing Search"
          fi
        else
          echo "‚ö†Ô∏è  Bing Search not found with prefix: $bingName"
        fi
      elif [ "$enableBing" = "true" ]; then
        echo "‚ÑπÔ∏è  Bing Search is enabled - skipping deletion"
      elif [ "$bingExists" = "false" ]; then
        echo "‚ÑπÔ∏è  Bing Search doesn't exist - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Bing Search deletion"
      fi
      
      echo ""
      
      # ======================================
      # Azure AI Vision
      # ======================================
      echo "Checking Azure AI Vision deletion conditions..."
      if [ "$enableDeleteForDisabledResources" = "true" ] && [ "$enableAzureAIVision" = "false" ]; then
        echo "‚úì Delete mode enabled and Azure AI Vision not enabled"
        
        # Find Azure AI Vision resource (vision-{projectName}-...)
        visionName="vision-${projectName}"
        echo "Looking for Azure AI Vision with prefix: $visionName"
        
        visionResource=$(az cognitiveservices account list \
          --resource-group "$targetResourceGroup" \
          --subscription "$subscriptionIdDevTestProd" \
          --query "[?starts_with(name, '$visionName')] | [0].name" -o tsv 2>/dev/null || echo "")
        
        if [ -n "$visionResource" ]; then
          echo "Found Azure AI Vision: $visionResource"
          
          # Delete private endpoints if in private networking mode
          if [ "$expectsPrivateEndpoints" = "true" ]; then
            pendName="p-${projectName}-vision-${genaiName}-pend"
            delete_private_endpoints "$pendName"
          fi
          
          # Delete the Azure AI Vision account
          echo "Deleting Azure AI Vision account: $visionResource"
          az cognitiveservices account delete \
            --name "$visionResource" \
            --resource-group "$targetResourceGroup" \
            --subscription "$subscriptionIdDevTestProd"
          
          if [ $? -eq 0 ]; then
            echo "‚úì Azure AI Vision deleted successfully"
          else
            echo "‚ö†Ô∏è  Failed to delete Azure AI Vision"
          fi
        else
          echo "‚ö†Ô∏è  Azure AI Vision not found with prefix: $visionName"
        fi
      elif [ "$enableAzureAIVision" = "true" ]; then
        echo "‚ÑπÔ∏è  Azure AI Vision is enabled - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Azure AI Vision deletion"
      fi
      
      echo ""
      
      # ======================================
      # Azure Speech Services
      # ======================================
      echo "Checking Azure Speech Services deletion conditions..."
      if [ "$enableDeleteForDisabledResources" = "true" ] && [ "$enableAzureSpeech" = "false" ]; then
        echo "‚úì Delete mode enabled and Azure Speech not enabled"
        
        # Find Azure Speech resource (speech-{projectName}-...)
        speechName="speech-${projectName}"
        echo "Looking for Azure Speech with prefix: $speechName"
        
        speechResource=$(az cognitiveservices account list \
          --resource-group "$targetResourceGroup" \
          --subscription "$subscriptionIdDevTestProd" \
          --query "[?starts_with(name, '$speechName')] | [0].name" -o tsv 2>/dev/null || echo "")
        
        if [ -n "$speechResource" ]; then
          echo "Found Azure Speech: $speechResource"
          
          # Delete private endpoints if in private networking mode
          if [ "$expectsPrivateEndpoints" = "true" ]; then
            pendName="p-${projectName}-speech-${genaiName}-pend"
            delete_private_endpoints "$pendName"
          fi
          
          # Delete the Azure Speech account
          echo "Deleting Azure Speech account: $speechResource"
          az cognitiveservices account delete \
            --name "$speechResource" \
            --resource-group "$targetResourceGroup" \
            --subscription "$subscriptionIdDevTestProd"
          
          if [ $? -eq 0 ]; then
            echo "‚úì Azure Speech deleted successfully"
          else
            echo "‚ö†Ô∏è  Failed to delete Azure Speech"
          fi
        else
          echo "‚ö†Ô∏è  Azure Speech not found with prefix: $speechName"
        fi
      elif [ "$enableAzureSpeech" = "true" ]; then
        echo "‚ÑπÔ∏è  Azure Speech is enabled - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Azure Speech deletion"
      fi
      
      echo ""
      
      # ======================================
      # AI Document Intelligence
      # ======================================
      echo "Checking AI Document Intelligence deletion conditions..."
      if [ "$enableDeleteForDisabledResources" = "true" ] && [ "$enableAIDocIntelligence" = "false" ]; then
        echo "‚úì Delete mode enabled and AI Document Intelligence not enabled"
        
        # Find Document Intelligence resource (docs-{projectName}-...)
        docsName="docs-${projectName}"
        echo "Looking for AI Document Intelligence with prefix: $docsName"
        
        docsResource=$(az cognitiveservices account list \
          --resource-group "$targetResourceGroup" \
          --subscription "$subscriptionIdDevTestProd" \
          --query "[?starts_with(name, '$docsName')] | [0].name" -o tsv 2>/dev/null || echo "")
        
        if [ -n "$docsResource" ]; then
          echo "Found AI Document Intelligence: $docsResource"
          
          # Delete private endpoints if in private networking mode
          if [ "$expectsPrivateEndpoints" = "true" ]; then
            pendName="p-${projectName}-docs-${genaiName}-pend"
            delete_private_endpoints "$pendName"
          fi
          
          # Delete the AI Document Intelligence account
          echo "Deleting AI Document Intelligence account: $docsResource"
          az cognitiveservices account delete \
            --name "$docsResource" \
            --resource-group "$targetResourceGroup" \
            --subscription "$subscriptionIdDevTestProd"
          
          if [ $? -eq 0 ]; then
            echo "‚úì AI Document Intelligence deleted successfully"
          else
            echo "‚ö†Ô∏è  Failed to delete AI Document Intelligence"
          fi
        else
          echo "‚ö†Ô∏è  AI Document Intelligence not found with prefix: $docsName"
        fi
      elif [ "$enableAIDocIntelligence" = "true" ]; then
        echo "‚ÑπÔ∏è  AI Document Intelligence is enabled - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for AI Document Intelligence deletion"
      fi
      
      echo ""
      
      # ======================================
      # Bing Custom Search
      # ======================================
      echo "Checking Bing Custom Search deletion conditions..."
      if [ "$enableDeleteForDisabledResources" = "true" ] && [ "$enableBingCustomSearch" = "false" ]; then
        echo "‚úì Delete mode enabled and Bing Custom Search not enabled"
        
        # Find Bing Custom Search resource (bing-custom-{projectName}-...)
        bingCustomName="bing-custom-${projectName}"
        echo "Looking for Bing Custom Search with prefix: $bingCustomName"
        
        # Bing resources are of type Microsoft.Bing/accounts
        bingCustomResource=$(az resource list \
          --resource-group "$targetResourceGroup" \
          --subscription "$subscriptionIdDevTestProd" \
          --resource-type "Microsoft.Bing/accounts" \
          --query "[?starts_with(name, '$bingCustomName')] | [0].name" -o tsv 2>/dev/null || echo "")
        
        if [ -n "$bingCustomResource" ]; then
          echo "Found Bing Custom Search: $bingCustomResource"
          
          # Bing Custom Search is deployed to 'global' location and typically doesn't support private endpoints
          # Delete the Bing Custom Search account
          echo "Deleting Bing Custom Search account: $bingCustomResource"
          az resource delete \
            --name "$bingCustomResource" \
            --resource-group "$targetResourceGroup" \
            --subscription "$subscriptionIdDevTestProd" \
            --resource-type "Microsoft.Bing/accounts"
          
          if [ $? -eq 0 ]; then
            echo "‚úì Bing Custom Search deleted successfully"
          else
            echo "‚ö†Ô∏è  Failed to delete Bing Custom Search"
          fi
        else
          echo "‚ö†Ô∏è  Bing Custom Search not found with prefix: $bingCustomName"
        fi
      elif [ "$enableBingCustomSearch" = "true" ]; then
        echo "‚ÑπÔ∏è  Bing Custom Search is enabled - skipping deletion"
      else
        echo "‚ÑπÔ∏è  Conditions not met for Bing Custom Search deletion"
      fi
      
      echo ""
      echo "=== Deletion task completed ==="
- task: AzureCLI@2
  displayName: '05d_Build default image offline, to private registry (ACR) if not exists'
  condition: and(eq(variables['enableContainerApps'], 'true'), ne(variables['debug_disable_05_build_acr_image'], 'true'),ne(variables['disable_whitelisting_for_build_agents'], 'true'))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |

      az account set --subscription "$(dev_test_prod_sub_id)"

      # Configuration flags
      use_public_image=true  # Set to true to use public image instead of building image
      mcr_ms_hello='mcr.microsoft.com/azuredocs/containerapps-helloworld:latest'
      
      # Create registry name from variables
      registryNameOrg="acrcommon$(aifactory_salt)$(admin_locationSuffix)$(admin_commonResourceSuffix)$(dev_test_prod)"
      registryName=$(echo "${registryNameOrg}" | tr -d '-')
      echo "Registry name: $registryName"
      
      # Set registry name for cleanup task
      echo "##vso[task.setvariable variable=acr_registry_name]$registryName"

      # Configure ACR export policy using REST API
      echo "Enabling ACR export policy"
      acrResourceGroup=$(az acr show --name $registryName --query resourceGroup -o tsv)
      echo "ACR Resource Group: $acrResourceGroup"
      az rest --method patch \
        --url "https://management.azure.com/subscriptions/$(dev_test_prod_sub_id)/resourceGroups/$acrResourceGroup/providers/Microsoft.ContainerRegistry/registries/$registryName?api-version=2023-07-01" \
        --body '{"properties":{"policies":{"exportPolicy":{"status":"enabled"}}}}'

      # Configure ACR for selective network access first
      echo "Configuring ACR for selective network access"
      az acr update --name $registryName --public-network-enabled true --default-action Deny
      
      # Wait for network rules to propagate
      echo "Waiting for network rules to propagate..."
      sleep 15
      
      # Get current IP addresses
      echo "Getting current IP addresses right before ACR operations..."
      CURRENT_IP1=$(curl -s http://ipinfo.io/ip 2>/dev/null || echo "")
      CURRENT_IP2=$(curl -s https://api.ipify.org 2>/dev/null || echo "")
      CURRENT_IP3=$(curl -s https://checkip.amazonaws.com 2>/dev/null || echo "")
      CURRENT_IP4=$(curl -s https://icanhazip.com 2>/dev/null || echo "")
      
      echo "Current IPs detected: $CURRENT_IP1, $CURRENT_IP2, $CURRENT_IP3, $CURRENT_IP4"
      
      # Store IPs that we actually add for cleanup - using pipeline variables
      ADDED_IPS_LIST=""
      SUCCESSFULLY_ADDED_IPS=""
      
      # Helper function to add IP with duplicate check
      add_ip_to_acr() {
        local ip="$1"
        local description="$2"
        
        echo "Adding $description: $ip"
        
        # Try to add the IP and capture both output and exit code
        local result
        result=$(az acr network-rule add --name $registryName --ip-address "$ip" 2>&1)
        local exit_code=$?
        
        if [ $exit_code -eq 0 ]; then
          echo "Successfully added: $ip"
          SUCCESSFULLY_ADDED_IPS="$SUCCESSFULLY_ADDED_IPS,$ip"
          return 0
        elif echo "$result" | grep -q "duplicate"; then
          echo "IP $ip already exists in ACR rules (duplicate) - skipping"
          return 0
        else
          echo "Failed to add $ip: $result"
          return 1
        fi
      }
      
      # Add broader IP ranges for Azure DevOps agents
      echo "Adding Azure DevOps service IP ranges (more permissive approach)"
      
      PRIMARY_IP=$(curl -s http://ipinfo.io/ip 2>/dev/null)
      if [ -n "$PRIMARY_IP" ]; then
        IP_BASE_16=$(echo $PRIMARY_IP | cut -d'.' -f1-2)
        BROAD_RANGE_16="${IP_BASE_16}.0.0/16"
        add_ip_to_acr "$BROAD_RANGE_16" "very broad IP range"
        
        IP_BASE_24=$(echo $PRIMARY_IP | cut -d'.' -f1-3)
        BROAD_RANGE_24="${IP_BASE_24}.0/24"
        add_ip_to_acr "$BROAD_RANGE_24" "broad IP range"
      fi
      
      # Add common Azure DevOps IP ranges
      AZURE_DEVOPS_RANGES=(
        "13.107.6.0/24"
        "13.107.9.0/24"
        "13.107.42.0/24"
        "13.107.43.0/24"
        "104.208.0.0/16"
        "52.0.0.0/8"
        "13.0.0.0/8"
        "150.171.22.0/24"
        "150.171.23.0/24"
        "150.171.73.0/24"
        "150.171.74.0/24"
        "150.171.75.0/24"
        "150.171.76.0/24"
      )
      
      for range in "${AZURE_DEVOPS_RANGES[@]}"; do
        add_ip_to_acr "$range" "Azure DevOps IP range"
      done
      
      # Add individual detected IPs as backup (with duplicate detection)
      CURRENT_IPS=("$CURRENT_IP1" "$CURRENT_IP2" "$CURRENT_IP3" "$CURRENT_IP4")
      PROCESSED_IPS=()
      
      for current_ip in "${CURRENT_IPS[@]}"; do
        if [ -n "$current_ip" ]; then
          # Check if we've already processed this IP
          if [[ " ${PROCESSED_IPS[@]} " =~ " ${current_ip} " ]]; then
            echo "IP $current_ip already processed - skipping duplicate"
            continue
          fi
          
          add_ip_to_acr "$current_ip" "detected IP"
          PROCESSED_IPS+=("$current_ip")
        fi
      done
      
      # Store only the successfully added IPs for cleanup (remove leading comma)
      SUCCESSFULLY_ADDED_IPS=$(echo "$SUCCESSFULLY_ADDED_IPS" | sed 's/^,//')
      echo "##vso[task.setvariable variable=acr_added_ips]$SUCCESSFULLY_ADDED_IPS"
      echo "Successfully added IPs for cleanup: $SUCCESSFULLY_ADDED_IPS"
      
      # Wait for network rules to propagate
      echo "Waiting for network rules to propagate..."
      sleep 30
      
      # Now check if image already exists (after network access is configured)
      echo "Checking if image containerapps-default:latest already exists in ACR..."
      if az acr repository show --name $registryName --image containerapps-default:latest &> /dev/null; then
        echo "‚úÖ Image containerapps-default:latest already exists in ACR. Skipping image creation but keeping IP rules for cleanup."
        # Note: We keep the SUCCESSFULLY_ADDED_IPS for cleanup, don't exit early
      else
        echo "‚ùå Image containerapps-default:latest does not exist. Proceeding with image creation..."
        
        # Create the image
        echo "Creating new image containerapps-default:latest..."
        
        if [ "$use_public_image" = true ]; then
          echo "Using public image: $mcr_ms_hello"
          timestamp=$(date +%Y%m%d-%H%M%S)
          
          echo "Importing public image to ACR with latest tag..."
          az acr import --name $registryName \
                        --source $mcr_ms_hello \
                        --image containerapps-default:latest \
                        --force
          
          echo "Importing public image to ACR with timestamp tag..."
          az acr import --name $registryName \
                        --source $mcr_ms_hello \
                        --image containerapps-default:$timestamp \
                        --force
          
          echo "Public image imported to ACR successfully!"
        else
          echo "Building custom image using ACR build..."
          az acr build --registry $registryName \
                       --image containerapps-default:latest \
                       --file azure-enterprise-scale-ml/environment_setup/aifactory/dockerfiles/acaDefault/Dockerfile \
                       azure-enterprise-scale-ml/environment_setup/aifactory/dockerfiles/acaDefault/
        fi
      fi

      # Verify image exists (whether it was already there or just created)
      sleep 30
      if az acr repository show --name $registryName --image containerapps-default:latest &> /dev/null; then
        echo "‚úÖ Image verified successfully in ACR."
      else
        echo "‚ùå Failed to verify image in ACR"
        exit 1
      fi
    workingDirectory: '$(System.DefaultWorkingDirectory)'
- task: AzureCLI@2
  displayName: 'Check and Delete Orphan Role Assignments'
  condition: succeeded()
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
      set -e
      
      echo "Checking for orphan role assignments..."
      
      # Set subscription
      az account set --subscription "$(dev_test_prod_sub_id)"
      
      # Input parameters
      commonRGNamePrefix="$(admin_aifactoryPrefixRG)"
      projectNumber="$(project_number_000)"
      projectName="prj${projectNumber}"
      locationSuffix="$(admin_locationSuffix)"
      envName="$(dev_test_prod)"
      aifactorySuffixRG="$(admin_aifactorySuffixRG)"
      vnetResourceGroupBase="$(vnetResourceGroupBase)"
      
      # Set project prefix and suffix from pipeline variables
      projectPrefix="$(projectPrefix)"
      projectSuffix="$(projectSuffix)"
      
      # Construct common resource group name
      commonResourceGroup="${commonRGNamePrefix}${vnetResourceGroupBase}-${locationSuffix}-${envName}${aifactorySuffixRG}"
      
      # Construct project resource group name
      projectNameReplaced="${projectName/prj/project}"
      projectResourceGroup="${commonRGNamePrefix}${projectPrefix}${projectNameReplaced}-${locationSuffix}-${envName}${aifactorySuffixRG}${projectSuffix}"
      
      # Function to check and delete orphan role assignments
      check_and_delete_orphans() {
        local resourceGroup=$1
        local rgScope="/subscriptions/$(dev_test_prod_sub_id)/resourceGroups/${resourceGroup}"
        
        echo "Checking resource group: $resourceGroup"
        echo "Scope: $rgScope"
        
        # Check if resource group exists
        if ! az group show --name "$resourceGroup" &>/dev/null; then
          echo "Resource group $resourceGroup does not exist, skipping..."
          return 0
        fi
        
        # Get orphan role assignments
        orphanCount=$(az role assignment list --scope "$rgScope" --query "[?principalName==null]" -o tsv | wc -l)
        
        if [ "$orphanCount" -gt 0 ]; then
          echo "Found $orphanCount orphan role assignment(s) in $resourceGroup"
          
          # Get orphan role assignment IDs
          orphanIds=$(az role assignment list --scope "$rgScope" --query "[?principalName==null].id" -o tsv)
          
          # Delete each orphan role assignment
          while IFS= read -r assignmentId; do
            if [ -n "$assignmentId" ]; then
              echo "Attempting to delete orphan role assignment: $assignmentId"
              
              if az role assignment delete --ids "$assignmentId" 2>&1; then
                echo "Successfully deleted orphan role assignment: $assignmentId"
              else
                echo "Warning: Failed to delete orphan role assignment: $assignmentId (may require additional permissions)"
              fi
            fi
          done <<< "$orphanIds"
        else
          echo "No orphan role assignments found in $resourceGroup"
        fi
      }
      
      # Check common resource group
      if [ -n "$commonResourceGroup" ]; then
        echo "=== Checking Common Resource Group ==="
        check_and_delete_orphans "$commonResourceGroup" || echo "Warning: Error processing common resource group, continuing..."
      fi
      
      # Check project resource group
      if [ -n "$projectResourceGroup" ]; then
        echo ""
        echo "=== Checking Project Resource Group ==="
        check_and_delete_orphans "$projectResourceGroup" || echo "Warning: Error processing project resource group, continuing..."
      fi
      
      echo ""
      echo "Orphan role assignment check completed"

- task: AzureCLI@2
  displayName: '61-foundation'
  condition: and(ne(variables['debug_disable_61_foundation'], 'true'), succeeded())
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
     --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-61-foundation" \
     --subscription "$(dev_test_prod_sub_id)" \
     --location "$(admin_location)" \
     --template-file "esml-genai-1/01-foundation.bicep" \
     --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
     --parameters useAdGroups="$(use_ad_groups)" \
     --parameters env="$(dev_test_prod)" \
     --parameters projectNumber="$(project_number_000)" \
     --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
     --parameters technicalAdminsEmail="$(technical_admins_email)" \
     --parameters location="$(admin_location)" \
     --parameters locationSuffix="$(admin_locationSuffix)" \
     --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
     --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters commonResourceName="$(vnetResourceGroupBase)" \
     --parameters vnetNameBase="$(vnetNameBase)" \
     --parameters vnetResourceGroupBase="$(vnetResourceGroupBase)" \
     --parameters vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters network_env="$(network_env)" \
     --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
     --parameters privateDnsAndVnetLinkAllGlobalLocation="false" \
     --parameters privDnsSubscription_param="$(privDnsSubscription_param)" \
     --parameters privDnsResourceGroup_param="$(privDnsResourceGroup_param)" \
     --parameters commonResourceGroup_param="$(commonResourceGroup_param)" \
     --parameters miACAExists="$(miACAExists)" \
     --parameters miPrjExists="$(miPrjExists)" \
     --parameters keyvaultExists="$(keyvaultExists)" \
     --parameters storageAccount1001Exists="$(storageAccount1001Exists)" \
     --parameters zoneAzurecontainerappsExists="$(zoneazurecontainerappsExists)" \
     --parameters zoneRedisExists="$(zoneredisExists)" \
     --parameters zonePostgresExists="$(zonepostgresExists)" \
     --parameters zoneSqlExists="$(zonesqlExists)" \
     --parameters zoneMongoExists="$(zoneMongoExists)" \
     --parameters zoneServicesAiExists="$(zoneServicesAiExists)" \
     --parameters zoneAPIMExists="$(zoneAPIMExists)" \
     --parameters projectServicePrincipleOID_SeedingKeyvaultName="$(project_service_principal_OID_seeding_kv_name)" \
     --parameters inputKeyvault="$(admin_bicep_kv_fw)" \
     --parameters inputKeyvaultResourcegroup="$(admin_bicep_kv_fw_rg)" \
     --parameters inputKeyvaultSubscription="$(admin_bicep_input_keyvault_subscription)" \
     --parameters aifactorySalt10char="$(aifactory_salt_random)" \
     --parameters randomValue="$(deployment_random_value)" \
     --parameters projectPrefix="$(projectPrefix)" \
     --parameters projectSuffix="$(projectSuffix)" \
     --parameters enableDebugging="true" \
     --parameters DEBUG_enableAIServices="$(enableAIServices)" \
     --parameters DEBUG_enableAIFoundryHub="$(enableAIFoundryHub)" \
     --parameters DEBUG_enableAISearch="$(enableAISearch)" \
     --parameters DEBUG_enableAzureMachineLearning="$(enableAzureMachineLearning)" \
     --parameters DEBUG_enableFunction="$(enableFunction)" \
     --parameters DEBUG_functionRuntime="$(functionRuntime)" \
     --parameters DEBUG_functionVersion="$(functionVersion)" \
     --parameters DEBUG_enableWebApp="$(enableWebApp)" \
     --parameters DEBUG_webAppRuntime="$(webAppRuntime)" \
     --parameters DEBUG_webAppRuntimeVersion="$(webAppRuntimeVersion)" \
     --parameters DEBUG_aseSku="$(aseSku)" \
     --parameters DEBUG_aseSkuCode="$(aseSkuCode)" \
     --parameters DEBUG_aseSkuWorkers="$(aseSkuWorkers)" \
     --parameters DEBUG_enableContainerApps="$(enableContainerApps)" \
     --parameters DEBUG_enableAppInsightsDashboard="$(enableAppInsightsDashboard)" \
     --parameters DEBUG_aca_a_registry_image="$(aca_a_registry_image)" \
     --parameters DEBUG_aca_w_registry_image="$(aca_w_registry_image)" \
     --parameters DEBUG_enableBingSearch="$(enableBingSearch)" \
     --parameters DEBUG_enableCosmosDB="$(enableCosmosDB)" \
     --parameters DEBUG_enableAzureOpenAI="$(enableAzureOpenAI)" \
     --parameters DEBUG_enableAzureAIVision="$(enableAzureAIVision)" \
     --parameters DEBUG_enableAzureSpeech="$(enableAzureSpeech)" \
     --parameters DEBUG_enableAIDocIntelligence="$(enableAIDocIntelligence)" \
     --parameters DEBUG_disableContributorAccessForUsers="$(disableContributorAccessForUsers)" \
     --parameters DEBUG_enablePostgreSQL="$(enablePostgreSQL)" \
     --parameters DEBUG_enableRedisCache="$(enableRedisCache)" \
     --parameters DEBUG_enableSQLDatabase="$(enableSQLDatabase)" \
     --parameters DEBUG_BYO_subnets="$(BYO_subnets)" \
     --parameters DEBUG_network_env_dev="$(network_env_dev)" \
     --parameters DEBUG_network_env_stage="$(network_env_stage)" \
     --parameters DEBUG_network_env_prod="$(network_env_prod)" \
     --parameters DEBUG_vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters DEBUG_vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters DEBUG_commonResourceGroup_param="$(commonResourceGroup_param)" \
     --parameters DEBUG_datalakeName_param="$(datalakeName_param)" \
     --parameters DEBUG_kvNameFromCOMMON_param="$(kvNameFromCOMMON_param)" \
     --parameters DEBUG_useCommonACR_override="$(useCommonACR_override)" \
     --parameters DEBUG_subnetCommon="$(subnetCommon)" \
     --parameters DEBUG_subnetCommonScoring="$(subnetCommonScoring)" \
     --parameters DEBUG_subnetCommonPowerbiGw="$(subnetCommonPowerbiGw)" \
     --parameters DEBUG_subnetProjGenAI="$(subnetProjGenAI)" \
     --parameters DEBUG_subnetProjAKS="$(subnetProjAKS)" \
     --parameters DEBUG_subnetProjACA="$(subnetProjACA)" \
     --parameters DEBUG_subnetProjDatabricksPublic="$(subnetProjDatabricksPublic)" \
     --parameters DEBUG_subnetProjDatabricksPrivate="$(subnetProjDatabricksPrivate)" \
     --parameters DEBUG_byoASEv3="$(byoASEv3)" \
     --parameters DEBUG_byoAseFullResourceId="$(byoAseFullResourceId)" \
     --parameters DEBUG_byoAseAppServicePlanResourceId="$(byoAseAppServicePlanResourceId)" \
     --parameters DEBUG_enablePublicGenAIAccess="$(enablePublicGenAIAccess)" \
     --parameters DEBUG_allowPublicAccessWhenBehindVnet="$(allowPublicAccessWhenBehindVnet)" \
     --parameters DEBUG_enablePublicAccessWithPerimeter="$(enablePublicAccessWithPerimeter)" \
     --parameters DEBUG_admin_aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters DEBUG_admin_commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters DEBUG_admin_prjResourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters DEBUG_aifactory_salt="$(aifactory_salt)" \
     --parameters DEBUG_admin_projectType="$(admin_projectType)" \
     --parameters DEBUG_project_number_000="$(project_number_000)" \
     --parameters DEBUG_project_service_principal_AppID_seeding_kv_name="$(project_service_principal_AppID_seeding_kv_name)" \
     --parameters DEBUG_project_service_principal_OID_seeding_kv_name="$(project_service_principal_OID_seeding_kv_name)" \
     --parameters DEBUG_project_service_principal_Secret_seeding_kv_name="$(project_service_principal_Secret_seeding_kv_name)" \
     --parameters DEBUG_project_IP_whitelist="$(project_IP_whitelist)" \
     --parameters DEBUG_deployModel_gpt_4="$(deployModel_gpt_4)" \
     --parameters DEBUG_deployModel_text_embedding_ada_002="$(deployModel_text_embedding_ada_002)" \
     --parameters DEBUG_deployModel_text_embedding_3_large="$(deployModel_text_embedding_3_large)" \
     --parameters DEBUG_deployModel_text_embedding_3_small="$(deployModel_text_embedding_3_small)" \
     --parameters DEBUG_deployModel_gpt_4o_mini="$(deployModel_gpt_4o_mini)" \
     --parameters diagnosticSettingLevel="$(diagnosticSettingLevel)" \
     --parameters tags='$(tags)' \
     --parameters tagsProject='$(tagsProject)' \
     --debug
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '62-core-infrastructure'
  condition: and(ne(variables['debug_disable_62_core_infrastructure'], 'true'), succeeded())
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     # Generate admin password first
     ADMIN_PASSWORD=$(date +%s | sha256sum | base64 | head -c 32)
     echo "Generated admin password"
     
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
     --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-62-core-infrastructure" \
     --subscription "$(dev_test_prod_sub_id)" \
     --location "$(admin_location)" \
     --template-file "esml-genai-1/02-core-infrastructure.bicep" \
     --parameters adminPassword="$ADMIN_PASSWORD" \
     --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
     --parameters env="$(dev_test_prod)" \
     --parameters projectNumber="$(project_number_000)" \
     --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
     --parameters technicalAdminsEmail="$(technical_admins_email)" \
     --parameters location="$(admin_location)" \
     --parameters locationSuffix="$(admin_locationSuffix)" \
     --parameters useCommonACR="$(useCommonACR_override)" \
     --parameters vnetNameBase="$(vnetNameBase)" \
     --parameters vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters network_env="$(network_env)" \
     --parameters common_subnet_name="$(common_subnet_name)" \
     --parameters subnetCommon="$(subnetCommon)" \
     --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
     --parameters privDnsSubscription_param="$(privDnsSubscription_param)" \
     --parameters privDnsResourceGroup_param="$(privDnsResourceGroup_param)" \
     --parameters commonResourceGroup_param="$(commonResourceGroup_param)" \
     --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
     --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters commonResourceName="$(vnetResourceGroupBase)" \
     --parameters projectServicePrincipleOID_SeedingKeyvaultName="$(project_service_principal_OID_seeding_kv_name)" \
     --parameters projectServicePrincipleAppID_SeedingKeyvaultName="$(project_service_principal_AppID_seeding_kv_name)" \
     --parameters projectServicePrincipleSecret_SeedingKeyvaultName="$(project_service_principal_Secret_seeding_kv_name)" \
     --parameters inputKeyvault="$(admin_bicep_kv_fw)" \
     --parameters inputKeyvaultResourcegroup="$(admin_bicep_kv_fw_rg)" \
     --parameters inputKeyvaultSubscription="$(admin_bicep_input_keyvault_subscription)" \
     --parameters cmk="$(cmk)" \
     --parameters cmkKeyName="$(cmkKeyName)" \
     --parameters IPwhiteList="$(project_IP_whitelist)" \
     --parameters storageAccount1001Exists="$(storageAccount1001Exists)" \
     --parameters storageAccount2001Exists="$(storageAccount2001Exists)" \
     --parameters keyvaultExists="$(keyvaultExists)" \
     --parameters acrProjectExists="$(acrProjectExists)" \
     --parameters miACAExists="$(miACAExists)" \
     --parameters miPrjExists="$(miPrjExists)" \
     --parameters vmExists="$(vmExists)" \
     --parameters bingExists="$(bingExists)" \
     --parameters randomValue="$(deployment_random_value)" \
     --parameters keyvaultSoftDeleteDays="$(admin_keyvaultSoftDeleteDays)" \
     --parameters aifactorySalt10char="$(aifactory_salt_random)" \
     --parameters tags='$(tags)' \
     --parameters tagsProject='$(tagsProject)' \
     --parameters enablePublicGenAIAccess="$(enablePublicGenAIAccess)" \
     --parameters enablePublicAccessWithPerimeter="$(enablePublicAccessWithPerimeter)" \
     --parameters allowPublicAccessWhenBehindVnet="$(allowPublicAccessWhenBehindVnet)" \
     --parameters projectPrefix="$(projectPrefix)" \
     --parameters projectSuffix="$(projectSuffix)" \
     --parameters acr_adminUserEnabled="$(acr_adminUserEnabled)" \
     --parameters acr_dedicated="$(acr_dedicated)" \
     --parameters containerRegistrySkuName="$(acr_SKU)" \
     --parameters enableProjectVM="$(enableProjectVM)" \
     --parameters diagnosticSettingLevel="$(diagnosticSettingLevel)" \
     --parameters updateKeyvaultRbac="$(updateKeyvaultRbac)" \
     --parameters enableLogicApps="$(enableLogicApps)" \
     --debug
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '63-cognitive-services'
  condition: and(succeeded(), or(ne(variables['debug_disable_63_cognitive_services'], 'true'), and(eq(variables['enableAFoundryCaphost'], 'true'), eq(variables['enableAIFoundry'], 'true'))))
  retryCountOnTaskFailure: 2
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
     --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-62-cognitive-services" \
     --subscription "$(dev_test_prod_sub_id)" \
     --location "$(admin_location)" \
     --template-file "esml-genai-1/03-cognitive-services.bicep" \
     --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
     --parameters env="$(dev_test_prod)" \
     --parameters projectNumber="$(project_number_000)" \
     --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
     --parameters technicalAdminsEmail="$(technical_admins_email)" \
     --parameters location="$(admin_location)" \
     --parameters locationSuffix="$(admin_locationSuffix)" \
     --parameters vnetNameBase="$(vnetNameBase)" \
     --parameters vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters network_env="$(network_env)" \
     --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
     --parameters privDnsSubscription_param="$(privDnsSubscription_param)" \
     --parameters privDnsResourceGroup_param="$(privDnsResourceGroup_param)" \
     --parameters commonResourceGroup_param="$(commonResourceGroup_param)" \
     --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
     --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters commonResourceName="$(vnetResourceGroupBase)" \
     --parameters IPwhiteList="$(project_IP_whitelist)" \
     --parameters openaiExists="$(openaiExists)" \
     --parameters aiSearchExists="$(aiSearchExists)" \
     --parameters aiServicesExists="$(aiServicesExists)" \
     --parameters keyvaultExists="$(keyvaultExists)" \
     --parameters storageAccount2001Exists="$(storageAccount2001Exists)" \
     --parameters storageAccount1001Exists="$(storageAccount1001Exists)" \
     --parameters randomValue="$(deployment_random_value)" \
     --parameters keyvaultSoftDeleteDays="$(admin_keyvaultSoftDeleteDays)" \
     --parameters aifactorySalt10char="$(aifactory_salt_random)" \
     --parameters enableAIServices="$(enableAIServices)" \
     --parameters enableAISearch="$(enableAISearch)" \
     --parameters aiSearchSKUName="$(admin_aiSearchTier)" \
     --parameters semanticSearchTier="$(admin_semanticSearchTier)" \
     --parameters enableAzureOpenAI="$(enableAzureOpenAI)" \
     --parameters enableContentSafety="$(enableContentSafety)" \
     --parameters enableAzureAIVision="$(enableAzureAIVision)" \
     --parameters enableAzureSpeech="$(enableAzureSpeech)" \
     --parameters enableAIDocIntelligence="$(enableAIDocIntelligence)" \
     --parameters deployModel_text_embedding_3_large="$(deployModel_text_embedding_3_large)" \
     --parameters deployModel_text_embedding_3_small="$(deployModel_text_embedding_3_small)" \
     --parameters deployModel_text_embedding_ada_002="$(deployModel_text_embedding_ada_002)" \
     --parameters deployModel_gpt_4o_mini="$(deployModel_gpt_4o_mini)" \
     --parameters default_gpt_capacity="$(default_gpt_capacity)" \
     --parameters default_model_sku="$(default_model_sku)" \
     --parameters modelGPTXName="$(modelGPTXName)" \
     --parameters modelGPTXVersion="$(modelGPTXVersion)" \
     --parameters modelGPTXSku="$(modelGPTXSku)" \
     --parameters modelGPTXCapacity="$(modelGPTXCapacity)" \
     --parameters tags='$(tags)' \
     --parameters tagsProject='$(tagsProject)' \
     --parameters enablePublicGenAIAccess="$(enablePublicGenAIAccess)" \
     --parameters enablePublicAccessWithPerimeter="$(enablePublicAccessWithPerimeter)" \
     --parameters projectPrefix="$(projectPrefix)" \
     --parameters projectSuffix="$(projectSuffix)" \
     --parameters miACAExists="$(miACAExists)" \
     --parameters miPrjExists="$(miPrjExists)" \
     --parameters diagnosticSettingLevel="$(diagnosticSettingLevel)" \
     --parameters enableBingCustomSearch="$(enableBingCustomSearch)" \
     --parameters enableBing="$(enableBing)" \
     --parameters enableAFoundryCaphost="$(enableAFoundryCaphost)" \
     --parameters enableAIFoundry="$(enableAIFoundry)" \
     --parameters enableAISearchSharedPrivateLink="$(enableAISearchSharedPrivateLink)" \
     --parameters cmk="$(cmk)" \
     --parameters cmkKeyName="$(cmkKeyName)" \
     --parameters admin_bicep_kv_fw="$(admin_bicep_kv_fw)" \
     --parameters admin_bicep_kv_fw_rg="$(admin_bicep_kv_fw_rg)" \
     --parameters admin_bicep_input_keyvault_subscription="$(admin_bicep_input_keyvault_subscription)" \
     --parameters addAISearch="$(addAISearch)" \
     --debug
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '64-databases'
  condition: and(succeeded(), or(ne(variables['debug_disable_64_databases'], 'true'), and(eq(variables['enableAFoundryCaphost'], 'true'), eq(variables['enableAIFoundry'], 'true'))))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
     --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-64-databases" \
     --subscription "$(dev_test_prod_sub_id)" \
     --location "$(admin_location)" \
     --template-file "esml-genai-1/04-databases.bicep" \
     --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
     --parameters env="$(dev_test_prod)" \
     --parameters projectNumber="$(project_number_000)" \
     --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
     --parameters technicalAdminsEmail="$(technical_admins_email)" \
     --parameters location="$(admin_location)" \
     --parameters locationSuffix="$(admin_locationSuffix)" \
     --parameters vnetNameBase="$(vnetNameBase)" \
     --parameters vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters network_env="$(network_env)" \
     --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
     --parameters privDnsSubscription_param="$(privDnsSubscription_param)" \
     --parameters privDnsResourceGroup_param="$(privDnsResourceGroup_param)" \
     --parameters commonResourceGroup_param="$(commonResourceGroup_param)" \
     --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
     --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters commonResourceName="$(vnetResourceGroupBase)" \
     --parameters projectServicePrincipleOID_SeedingKeyvaultName="$(project_service_principal_OID_seeding_kv_name)" \
     --parameters inputKeyvault="$(admin_bicep_kv_fw)" \
     --parameters inputKeyvaultResourcegroup="$(admin_bicep_kv_fw_rg)" \
     --parameters inputKeyvaultSubscription="$(admin_bicep_input_keyvault_subscription)" \
     --parameters IPwhiteList="$(project_IP_whitelist)" \
     --parameters cosmosDBExists="$(cosmosDBExists)" \
     --parameters redisExists="$(redisExists)" \
     --parameters postgreSQLExists="$(postgreSQLExists)" \
     --parameters sqlServerExists="$(sqlServerExists)" \
     --parameters randomValue="$(deployment_random_value)" \
     --parameters aifactorySalt10char="$(aifactory_salt_random)" \
     --parameters enableCosmosDB="$(enableCosmosDB)" \
     --parameters cosmosKind="$(cosmosKind)" \
     --parameters enablePostgreSQL="$(enablePostgreSQL)" \
     --parameters postgreSQLVersion="17" \
     --parameters enableRedisCache="$(enableRedisCache)" \
     --parameters enableSQLDatabase="$(enableSQLDatabase)" \
     --parameters useAdGroups="$(use_ad_groups)" \
     --parameters tags='$(tags)' \
     --parameters tagsProject='$(tagsProject)' \
     --parameters enablePublicGenAIAccess="$(enablePublicGenAIAccess)" \
     --parameters enablePublicAccessWithPerimeter="$(enablePublicAccessWithPerimeter)" \
     --parameters projectPrefix="$(projectPrefix)" \
     --parameters projectSuffix="$(projectSuffix)" \
     --parameters diagnosticSettingLevel="$(diagnosticSettingLevel)" \
     --parameters enableAFoundryCaphost="$(enableAFoundryCaphost)" \
     --parameters enableAIFoundry="$(enableAIFoundry)" \
     --parameters cmk="$(cmk)" \
     --parameters cmkKeyName="$(cmkKeyName)" \
     --parameters admin_bicep_kv_fw="$(admin_bicep_kv_fw)" \
     --parameters admin_bicep_kv_fw_rg="$(admin_bicep_kv_fw_rg)" \
     --parameters admin_bicep_input_keyvault_subscription="$(admin_bicep_input_keyvault_subscription)" \
     --debug
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '65-compute-services'
  condition: and(ne(variables['debug_disable_65_compute_services'], 'true'), succeeded())
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
     --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-65-compute-services" \
     --subscription "$(dev_test_prod_sub_id)" \
     --location "$(admin_location)" \
     --template-file "esml-genai-1/05-compute-services.bicep" \
     --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
     --parameters env="$(dev_test_prod)" \
     --parameters projectNumber="$(project_number_000)" \
     --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
     --parameters technicalAdminsEmail="$(technical_admins_email)" \
     --parameters location="$(admin_location)" \
     --parameters locationSuffix="$(admin_locationSuffix)" \
     --parameters useCommonACR="$(useCommonACR_override)" \
     --parameters vnetNameBase="$(vnetNameBase)" \
     --parameters vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters network_env="$(network_env)" \
     --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
     --parameters privDnsSubscription_param="$(privDnsSubscription_param)" \
     --parameters privDnsResourceGroup_param="$(privDnsResourceGroup_param)" \
     --parameters commonResourceGroup_param="$(commonResourceGroup_param)" \
     --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
     --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters commonResourceName="$(vnetResourceGroupBase)" \
     --parameters IPwhiteList="$(project_IP_whitelist)" \
     --parameters containerAppsEnvExists="$(containerAppsEnvExists)" \
     --parameters containerAppAExists="$(containerAppAExists)" \
     --parameters containerAppWExists="$(containerAppWExists)" \
     --parameters functionAppExists="$(functionAppExists)" \
     --parameters bingExists="$(bingExists)" \
     --parameters webAppExists="$(webAppExists)" \
     --parameters funcAppServicePlanExists="$(funcAppServicePlanExists)" \
     --parameters webAppServicePlanExists="$(webAppServicePlanExists)" \
     --parameters applicationInsightExists="$(applicationInsightExists)" \
     --parameters randomValue="$(deployment_random_value)" \
     --parameters aifactorySalt10char="$(aifactory_salt_random)" \
     --parameters enableContainerApps="$(enableContainerApps)" \
     --parameters enableFunction="$(enableFunction)" \
     --parameters enableWebApp="$(enableWebApp)" \
     --parameters enableBingSearch="$(enableBingSearch)" \
     --parameters enableAzureOpenAI="$(enableAzureOpenAI)" \
     --parameters enableAISearch="$(enableAISearch)" \
     --parameters enableAIServices="$(enableAIServices)" \
     --parameters functionRuntime="$(functionRuntime)" \
     --parameters functionVersion="$(functionVersion)" \
     --parameters webAppRuntime="$(webAppRuntime)" \
     --parameters webAppRuntimeVersion="$(webAppRuntimeVersion)" \
     --parameters aseSku="$(aseSku)" \
     --parameters aseSkuCode="$(aseSkuCode)" \
     --parameters aseSkuWorkers="$(aseSkuWorkers)" \
     --parameters byoASEv3="$(byoASEv3)" \
     --parameters byoAseFullResourceId="$(byoAseFullResourceId)" \
     --parameters enableAppInsightsDashboard="$(enableAppInsightsDashboard)" \
     --parameters aca_a_registry_image="$(aca_a_registry_image)" \
     --parameters aca_w_registry_image="$(aca_w_registry_image)" \
     --parameters tags='$(tags)' \
     --parameters tagsProject='$(tagsProject)' \
     --parameters enablePublicGenAIAccess="$(enablePublicGenAIAccess)" \
     --parameters enablePublicAccessWithPerimeter="$(enablePublicAccessWithPerimeter)" \
     --parameters projectPrefix="$(projectPrefix)" \
     --parameters projectSuffix="$(projectSuffix)" \
     --parameters aiFoundryV2Exists="$(aiFoundryV2Exists)" \
     --parameters enableAIFoundry="$(enableAIFoundry)" \
     --parameters disableAgentNetworkInjection="$(disableAgentNetworkInjection)" \
     --parameters diagnosticSettingLevel="$(diagnosticSettingLevel)" \
     --parameters addAISearch="$(addAISearch)" \
     --debug
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '66-ai-platform'
  condition: and(ne(variables['debug_disable_66_ai_platform'], 'true'), succeeded())
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
     --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-66-ai-platform" \
     --subscription "$(dev_test_prod_sub_id)" \
     --location "$(admin_location)" \
     --template-file "esml-genai-1/06-ai-platform.bicep" \
     --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
     --parameters env="$(dev_test_prod)" \
     --parameters projectNumber="$(project_number_000)" \
     --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
     --parameters technicalAdminsEmail="$(technical_admins_email)" \
     --parameters location="$(admin_location)" \
     --parameters locationSuffix="$(admin_locationSuffix)" \
     --parameters useCommonACR="$(useCommonACR_override)" \
     --parameters vnetNameBase="$(vnetNameBase)" \
     --parameters vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters network_env="$(network_env)" \
     --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
     --parameters privDnsSubscription_param="$(privDnsSubscription_param)" \
     --parameters privDnsResourceGroup_param="$(privDnsResourceGroup_param)" \
     --parameters commonResourceGroup_param="$(commonResourceGroup_param)" \
     --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
     --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters commonResourceName="$(vnetResourceGroupBase)" \
     --parameters IPwhiteList="$(project_IP_whitelist)" \
     --parameters aiHubExists="$(aiHubExists)" \
     --parameters aifProjectExists="$(aifProjectExists)" \
     --parameters miPrjExists="$(miPrjExists)" \
     --parameters randomValue="$(deployment_random_value)" \
     --parameters aifactorySalt10char="$(aifactory_salt_random)" \
     --parameters enableAIFoundryHub="$(enableAIFoundryHub)" \
     --parameters addAIFoundryHub="$(addAIFoundryHub)" \
     --parameters enableAISearch="$(enableAISearch)" \
     --parameters enableAIServices="$(enableAIServices)" \
     --parameters projectServicePrincipleOID_SeedingKeyvaultName="$(project_service_principal_OID_seeding_kv_name)" \
     --parameters inputKeyvault="$(admin_bicep_kv_fw)" \
     --parameters inputKeyvaultResourcegroup="$(admin_bicep_kv_fw_rg)" \
     --parameters inputKeyvaultSubscription="$(admin_bicep_input_keyvault_subscription)" \
     --parameters deployModel_text_embedding_ada_002="$(deployModel_text_embedding_ada_002)" \
     --parameters deployModel_text_embedding_3_large="$(deployModel_text_embedding_3_large)" \
     --parameters deployModel_text_embedding_3_small="$(deployModel_text_embedding_3_small)" \
     --parameters default_embedding_capacity="$(default_embedding_capacity)" \
     --parameters deployModel_gpt_4o_mini="$(deployModel_gpt_4o_mini)" \
     --parameters default_gpt_capacity="$(default_gpt_capacity)" \
     --parameters default_model_sku="$(default_model_sku)" \
     --parameters deployModel_gpt_4o="$(deployModel_gpt_4o)" \
     --parameters deployModel_gpt_X="$(deployModel_gpt_X)" \
     --parameters modelGPTXName="$(modelGPTXName)" \
     --parameters modelGPTXVersion="$(modelGPTXVersion)" \
     --parameters modelGPTXSku="$(modelGPTXSku)" \
     --parameters modelGPTXCapacity="$(modelGPTXCapacity)" \
     --parameters tags='$(tags)' \
     --parameters tagsProject='$(tagsProject)' \
     --parameters enablePublicGenAIAccess="$(enablePublicGenAIAccess)" \
     --parameters allowPublicAccessWhenBehindVnet="$(allowPublicAccessWhenBehindVnet)" \
     --parameters enablePublicAccessWithPerimeter="$(enablePublicAccessWithPerimeter)" \
     --parameters common_subnet_name="$(common_subnet_name)" \
     --parameters subnetCommon="$(subnetCommon)" \
     --parameters subnetCommonScoring="$(subnetCommonScoring)" \
     --parameters subscriptionIdDevTestProd="$(dev_test_prod_sub_id)" \
     --parameters useAdGroups="$(use_ad_groups)" \
     --parameters projectPrefix="$(projectPrefix)" \
     --parameters projectSuffix="$(projectSuffix)" \
     --parameters diagnosticSettingLevel="$(diagnosticSettingLevel)" \
     --parameters cmk="$(cmk)" \
     --parameters cmkKeyName="$(cmkKeyName)" \
     --parameters addAISearch="$(addAISearch)" \
     --debug
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '67-data_ml_platform'
  condition: and(ne(variables['debug_disable_67_data_ml_platform'], 'true'), succeeded())
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
     --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-67-data-ml-platform" \
     --subscription "$(dev_test_prod_sub_id)" \
     --location "$(admin_location)" \
     --template-file "esml-genai-1/07-ml-data-platform.bicep" \
     --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
     --parameters env="$(dev_test_prod)" \
     --parameters projectNumber="$(project_number_000)" \
     --parameters location="$(admin_location)" \
     --parameters locationSuffix="$(admin_locationSuffix)" \
     --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters aifactorySalt10char="$(aifactory_salt_random)" \
     --parameters randomValue="$(deployment_random_value)" \
     --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters subscriptionIdDevTestProd="$(dev_test_prod_sub_id)" \
     --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
     --parameters technicalAdminsEmail="$(technical_admins_email)" \
     --parameters enablePublicAccessWithPerimeter="$(enablePublicAccessWithPerimeter)" \
     --parameters tags='$(tags)' \
     --parameters tagsProject='$(tagsProject)' \
     --parameters network_env="$(network_env)" \
     --parameters vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters vnetNameBase="$(vnetNameBase)" \
     --parameters vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
     --parameters commonResourceName="$(vnetResourceGroupBase)" \
     --parameters projectPrefix="$(projectPrefix)" \
     --parameters projectSuffix="$(projectSuffix)" \
     --parameters aks_dev_sku_override="$(admin_aks_gpu_sku_dev_override)" \
     --parameters aks_test_prod_sku_override="$(admin_aks_gpu_sku_test_prod_override)" \
     --parameters aks_version_override="$(admin_aks_version_override)" \
     --parameters aks_dev_nodes_override="$(admin_aks_nodes_dev_override)" \
     --parameters aks_test_prod_nodes_override="$(admin_aks_nodes_testProd_override)" \
     --parameters aml_ci_dev_sku_override="$(admin_aml_computeInstance_dev_sku_override)" \
     --parameters aml_ci_test_prod_sku_override="$(admin_aml_computeInstance_testProd_sku_override)" \
     --parameters aml_cluster_dev_sku_override="$(admin_aml_cluster_sku_dev_override)" \
     --parameters aml_cluster_test_prod_sku_override="$(admin_aml_cluster_sku_testProd_override)" \
     --parameters aml_cluster_dev_nodes_override="$(admin_aml_cluster_maxNodes_dev_override)" \
     --parameters aml_cluster_test_prod_nodes_override="$(admin_aml_cluster_maxNodes_testProd_override)" \
     --parameters AMLStudioUIPrivate="$(AMLStudioUIPrivate)" \
     --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
     --parameters useCommonACR="$(useCommonACR_override)" \
     --parameters useAdGroups="$(use_ad_groups)" \
     --parameters IPwhiteList="$(project_IP_whitelist)" \
     --parameters inputKeyvault="$(admin_bicep_kv_fw)" \
     --parameters inputKeyvaultResourcegroup="$(admin_bicep_kv_fw_rg)" \
     --parameters inputKeyvaultSubscription="$(admin_bicep_input_keyvault_subscription)" \
     --parameters projectServicePrincipleOID_SeedingKeyvaultName="$(project_service_principal_OID_seeding_kv_name)" \
     --parameters amlExists="$(amlExists)" \
     --parameters aksExists="$(aksExists)" \
     --parameters dataFactoryExists="$(dataFactoryExists)" \
     --parameters databricksExists="$(databricksExists)" \
     --parameters enableDatafactory="$(enableDatafactory)" \
     --parameters enableAzureMachineLearning="$(enableAzureMachineLearning)" \
     --parameters enableDatabricks="$(enableDatabricks)" \
     --parameters diagnosticSettingLevel="$(diagnosticSettingLevel)" \
     --parameters addAzureMachineLearning="$(addAzureMachineLearning)" \
     --parameters enableAksForAzureML="$(enableAksForAzureML)" \
     --parameters aksOutboundType="$(aksOutboundType)" \
     --parameters aksPrivateDNSZone="$(aksPrivateDNSZone)" \
     --parameters cmk="$(cmk)" \
     --parameters cmkKeyName="$(cmkKeyName)"
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '68-integration'
  condition: and(ne(variables['debug_disable_68_integration'], 'true'), succeeded())
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
     --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-68-integration" \
     --subscription "$(dev_test_prod_sub_id)" \
     --location "$(admin_location)" \
     --template-file "esml-genai-1/11-integration.bicep" \
     --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
     --parameters env="$(dev_test_prod)" \
     --parameters projectNumber="$(project_number_000)" \
     --parameters location="$(admin_location)" \
     --parameters locationSuffix="$(admin_locationSuffix)" \
     --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters aifactorySalt10char="$(aifactory_salt_random)" \
     --parameters randomValue="$(deployment_random_value)" \
     --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters subscriptionIdDevTestProd="$(dev_test_prod_sub_id)" \
     --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
     --parameters technicalAdminsEmail="$(technical_admins_email)" \
     --parameters enablePublicAccessWithPerimeter="$(enablePublicAccessWithPerimeter)" \
     --parameters tags='$(tags)' \
     --parameters tagsProject='$(tagsProject)' \
     --parameters network_env="$(network_env)" \
     --parameters vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters vnetNameBase="$(vnetNameBase)" \
     --parameters vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
     --parameters commonResourceName="$(vnetResourceGroupBase)" \
     --parameters projectPrefix="$(projectPrefix)" \
     --parameters projectSuffix="$(projectSuffix)" \
     --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
     --parameters useCommonACR="$(useCommonACR_override)" \
     --parameters useAdGroups="$(use_ad_groups)" \
     --parameters IPwhiteList="$(project_IP_whitelist)" \
     --parameters inputKeyvault="$(admin_bicep_kv_fw)" \
     --parameters inputKeyvaultResourcegroup="$(admin_bicep_kv_fw_rg)" \
     --parameters inputKeyvaultSubscription="$(admin_bicep_input_keyvault_subscription)" \
     --parameters projectServicePrincipleOID_SeedingKeyvaultName="$(project_service_principal_OID_seeding_kv_name)" \
     --parameters enableLogicApps="$(enableLogicApps)" \
     --parameters enableEventHubs="$(enableEventHubs)" \
     --parameters logicAppsExists="$(logicAppsExists)" \
     --parameters eventHubsExists="$(eventHubsExists)" \
     --parameters functionAppExists="$(functionAppExists)" \
     --parameters enableFunction="$(enableFunction)" \
     --parameters enableWebApp="$(enableWebApp)" \
     --parameters webAppExists="$(webAppExists)" \
     --parameters enableBotService="$(enableBotService)" \
     --parameters addAIFoundry="$(addAIFoundry)" \
     --parameters botServiceExists="$(botServiceExists)" \
     --parameters botServiceSku="S1" \
     --parameters diagnosticSettingLevel="$(diagnosticSettingLevel)"
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '99_check_acr_role_assignments'
  condition: succeeded()
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     #!/bin/bash

     # Check if any user or group already has acrPush on the common ACR
     az account set --subscription "$(dev_test_prod_sub_id)"

     # Input parameters
     commonRGNamePrefix="$(admin_aifactoryPrefixRG)"
     projectNumber="$(project_number_000)"
     projectName="prj${projectNumber}"
     locationSuffix="$(admin_locationSuffix)"
     envName="$(dev_test_prod)"
     aifactorySuffixRG="$(admin_aifactorySuffixRG)"
     vnetResourceGroupBase="$(vnetResourceGroupBase)"
     projectPrefix="$(projectPrefix)"
     projectSuffix="$(projectSuffix)"

     # Construct common resource group name
     commonResourceGroup="${commonRGNamePrefix}${vnetResourceGroupBase}-${locationSuffix}-${envName}${aifactorySuffixRG}"
     echo "Common RG resolved to: ${commonResourceGroup}"

     acrPushRoleId="8311e382-0749-4cb8-b61a-304f252e45ec"

     # Find the ACR in the common resource group (pick first if multiple)
     acrName=$(az acr list --resource-group "$commonResourceGroup" --query "[0].name" -o tsv 2>/dev/null || true)

     if [ -z "$acrName" ]; then
       echo "No ACR found in ${commonResourceGroup}; will not skip ACR role assignments."
       echo "##vso[task.setvariable variable=skipACRAssignments]false"
       exit 0
     fi

     acrScope="/subscriptions/$(dev_test_prod_sub_id)/resourceGroups/${commonResourceGroup}/providers/Microsoft.ContainerRegistry/registries/${acrName}"
     echo "Checking existing acrPush assignments on ${acrName} at scope ${acrScope}"

     assignments=$(az role assignment list --scope "$acrScope" --role "$acrPushRoleId" --query "[?principalType=='User' || principalType=='Group']" -o tsv 2>/dev/null || true)

     if [ -n "$assignments" ]; then
       echo "Found existing user/group acrPush role assignment(s); setting skipACRAssignments=true"
       echo "##vso[task.setvariable variable=skipACRAssignments]true"
     else
       echo "No user/group acrPush assignments found; setting skipACRAssignments=false"
       echo "##vso[task.setvariable variable=skipACRAssignments]false"
     fi
- task: AzureCLI@2
  displayName: '100-rbac-security'
  condition: and(ne(variables['debug_disable_100_rbac_security'], 'true'), succeeded())
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
     --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-100-rbac-security" \
     --subscription "$(dev_test_prod_sub_id)" \
     --location "$(admin_location)" \
     --template-file "esml-genai-1/08-rbac-security.bicep" \
     --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
     --parameters env="$(dev_test_prod)" \
     --parameters projectNumber="$(project_number_000)" \
     --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
     --parameters technicalAdminsEmail="$(technical_admins_email)" \
     --parameters location="$(admin_location)" \
     --parameters locationSuffix="$(admin_locationSuffix)" \
     --parameters useCommonACR="$(useCommonACR_override)" \
     --parameters vnetNameBase="$(vnetNameBase)" \
     --parameters vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters network_env="$(network_env)" \
     --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
     --parameters privDnsSubscription_param="$(privDnsSubscription_param)" \
     --parameters privDnsResourceGroup_param="$(privDnsResourceGroup_param)" \
     --parameters commonResourceGroup_param="$(commonResourceGroup_param)" \
     --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
     --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters commonResourceName="$(vnetResourceGroupBase)" \
     --parameters azureMachineLearningObjectId="$(azure_machinelearning_sp_oid)" \
     --parameters useAdGroups="$(use_ad_groups)" \
     --parameters randomValue="$(deployment_random_value)" \
     --parameters aifactorySalt10char="$(aifactory_salt_random)" \
     --parameters enableAzureMachineLearning="$(enableAzureMachineLearning)" \
     --parameters enableAIFoundryHub="$(enableAIFoundryHub)" \
     --parameters addAIFoundryHub="$(addAIFoundryHub)" \
     --parameters enableAIServices="$(enableAIServices)" \
     --parameters enableAIFoundry="$(enableAIFoundry)" \
     --parameters enableAIFoundry="$(enableAIFoundry)" \
     --parameters enableAISearch="$(enableAISearch)" \
     --parameters enableFunction="$(enableFunction)" \
     --parameters enableWebApp="$(enableWebApp)" \
     --parameters enableContainerApps="$(enableContainerApps)" \
     --parameters enableAppInsightsDashboard="$(enableAppInsightsDashboard)" \
     --parameters enableAzureOpenAI="$(enableAzureOpenAI)" \
     --parameters enableAzureAIVision="$(enableAzureAIVision)" \
     --parameters enableAzureSpeech="$(enableAzureSpeech)" \
     --parameters enableAIDocIntelligence="$(enableAIDocIntelligence)" \
     --parameters disableContributorAccessForUsers="$(disableContributorAccessForUsers)" \
     --parameters disableRBACAdminOnRGForUsers="$(disableRBACAdminOnRGForUsers)" \
     --parameters enableCosmosDB="$(enableCosmosDB)" \
     --parameters enablePostgreSQL="$(enablePostgreSQL)" \
     --parameters enableRedisCache="$(enableRedisCache)" \
     --parameters enableSQLDatabase="$(enableSQLDatabase)" \
     --parameters enableLogicApps="$(enableLogicApps)" \
     --parameters inputKeyvault="$(admin_bicep_kv_fw)" \
     --parameters inputKeyvaultResourcegroup="$(admin_bicep_kv_fw_rg)" \
     --parameters inputKeyvaultSubscription="$(admin_bicep_input_keyvault_subscription)" \
     --parameters projectServicePrincipleOID_SeedingKeyvaultName="$(project_service_principal_OID_seeding_kv_name)" \
     --parameters commonLakeNamePrefixMax8chars="$(commonLakeNamePrefixMax8chars)" \
     --parameters tags='$(tags)' \
     --parameters tagsProject='$(tagsProject)' \
     --parameters projectPrefix="$(projectPrefix)" \
     --parameters projectSuffix="$(projectSuffix)" \
     --parameters dataFactoryExists="$(dataFactoryExists)" \
     --parameters aksExists="$(aksExists)" \
     --parameters amlExists="$(amlExists)" \
     --parameters aiHubExists="$(aiHubExists)" \
     --parameters aiServicesExists="$(aiServicesExists)" \
     --parameters openaiExists="$(openaiExists)" \
     --parameters updateRbac="$(updateRbac)" \
     --parameters miPrjExists="$(miPrjExists)" \
     --parameters diagnosticSettingLevel="$(diagnosticSettingLevel)" \
     --parameters addAISearch="$(addAISearch)" \
     --parameters skipExistingRoleAssignments="$(skipACRAssignments)" \
     --debug
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '69-aifoundry-2025-1stOption'
  condition: and(ne(variables['debug_disable_69_aifoundry_2025'], 'true'), succeeded(), or(eq(variables['foundryDeploymentType'], '1'), eq(variables['foundryDeploymentType'], '3')))
  # continueOnError: true
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
      --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-69-aifoundry-2025-account-1st" \
      --subscription "$(dev_test_prod_sub_id)" \
      --location "$(admin_location)" \
      --template-file "esml-genai-1/09-ai-foundry-2025-v2.bicep" \
      --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
      --parameters targetSubscriptionId="$(dev_test_prod_sub_id)" \
      --parameters commonResourceGroup_param="$(commonResourceGroup_param)" \
      --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
      --parameters commonResourceName="$(vnetResourceGroupBase)" \
      --parameters locationSuffix="$(admin_locationSuffix)" \
      --parameters env="$(dev_test_prod)" \
      --parameters projectNumber="$(project_number_000)" \
      --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
      --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
      --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
      --parameters location="$(admin_location)" \
      --parameters aifactorySalt10char="$(aifactory_salt_random)" \
      --parameters randomValue="$(deployment_random_value)" \
      --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
      --parameters technicalAdminsEmail="$(technical_admins_email)" \
      --parameters subscriptionIdDevTestProd="$(dev_test_prod_sub_id)" \
      --parameters apiManagementResourceId="$(foundryApiManagementResourceId)" \
      --parameters privDnsSubscription_param="$(privDnsSubscription_param)" \
      --parameters privDnsResourceGroup_param="$(privDnsResourceGroup_param)" \
      --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
      --parameters projectPrefix="$(projectPrefix)" \
      --parameters projectSuffix="$(projectSuffix)" \
      --parameters tags='$(tagsProject)' \
      --parameters addAIFoundry="$(addAIFoundry)" \
      --parameters enableAISearch="$(enableAISearch)" \
      --parameters enableAISearchSharedPrivateLink="$(enableAISearchSharedPrivateLink)" \
      --parameters aiFoundryV2Exists="$(aiFoundryV2Exists)" \
      --parameters aiFoundryV2ProjectExists="$(aiFoundryV2ProjectExists)" \
      --parameters enableDefenderforAISubLevel="$(enableDefenderforAISubLevel)" \
      --parameters enableDefenderforAIResourceLevel="$(enableDefenderforAIResourceLevel)" \
      --debug
      
      # If the deployment succeeded, set a variable to skip the fallback option
      if [ $? -eq 0 ]; then
        echo "##vso[task.setvariable variable=foundry_1st_option_succeeded]true"
        echo "First option succeeded - will skip second option"
      fi
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '69a-aifoundry-2025-2ndOption-Account'
  condition: and(ne(variables['debug_disable_69_aifoundry_2025'], 'true'), not(canceled()), ne(variables['foundry_1st_option_succeeded'], 'true'), ne(variables['aiFoundryV2Exists'], 'true'), or(eq(variables['foundryDeploymentType'], '2'), eq(variables['foundryDeploymentType'], '3')))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
     --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-69-aif-a" \
     --subscription "$(dev_test_prod_sub_id)" \
     --location "$(admin_location)" \
     --template-file "esml-genai-1/09-ai-foundry-2025-v4.bicep" \
     --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
     --parameters env="$(dev_test_prod)" \
     --parameters projectNumber="$(project_number_000)" \
     --parameters location="$(admin_location)" \
     --parameters locationSuffix="$(admin_locationSuffix)" \
     --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters enableAISearch="$(enableAISearch)" \
     --parameters enableCosmosDB="$(enableCosmosDB)" \
     --parameters deployModel_gpt_X="$(deployModel_gpt_X)" \
     --parameters modelGPTXName="$(modelGPTXName)" \
     --parameters modelGPTXVersion="$(modelGPTXVersion)" \
     --parameters modelGPTXSku="$(modelGPTXSku)" \
     --parameters modelGPTXCapacity="$(modelGPTXCapacity)" \
     --parameters deployModel_text_embedding_ada_002="$(deployModel_text_embedding_ada_002)" \
     --parameters deployModel_text_embedding_3_large="$(deployModel_text_embedding_3_large)" \
     --parameters deployModel_text_embedding_3_small="$(deployModel_text_embedding_3_small)" \
     --parameters default_embedding_capacity="$(default_embedding_capacity)" \
     --parameters default_gpt_capacity="$(default_gpt_capacity)" \
     --parameters deployModel_gpt_4o="$(deployModel_gpt_4o)" \
     --parameters default_gpt_4o_version="$(default_gpt_4o_version)" \
     --parameters deployModel_gpt_4o_mini="$(deployModel_gpt_4o_mini)" \
     --parameters default_gpt_4o_mini_version="$(default_gpt_4o_mini_version)" \
     --parameters default_model_sku="$(default_model_sku)" \
     --parameters enablePublicAccessWithPerimeter="$(enablePublicAccessWithPerimeter)" \
     --parameters enablePublicGenAIAccess="$(enablePublicGenAIAccess)" \
     --parameters allowPublicAccessWhenBehindVnet="$(allowPublicAccessWhenBehindVnet)" \
     --parameters IPwhiteList="$(project_IP_whitelist)" \
     --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
     --parameters vnetNameBase="$(vnetNameBase)" \
     --parameters vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters network_env="$(network_env)" \
     --parameters common_subnet_name="$(common_subnet_name)" \
     --parameters subnetCommon="$(subnetCommon)" \
     --parameters privDnsSubscription_param="$(privDnsSubscription_param)" \
     --parameters privDnsResourceGroup_param="$(privDnsResourceGroup_param)" \
     --parameters commonResourceGroup_param="$(commonResourceGroup_param)" \
     --parameters tagsProject='$(tagsProject)' \
     --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
     --parameters commonResourceName="$(vnetResourceGroupBase)" \
     --parameters aifactorySalt10char="$(aifactory_salt_random)" \
     --parameters randomValue="$(deployment_random_value)" \
     --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
     --parameters technicalAdminsEmail="$(technical_admins_email)" \
     --parameters subscriptionIdDevTestProd="$(dev_test_prod_sub_id)" \
     --parameters projectPrefix="$(projectPrefix)" \
     --parameters projectSuffix="$(projectSuffix)" \
     --parameters inputKeyvault="$(admin_bicep_kv_fw)" \
     --parameters inputKeyvaultResourcegroup="$(admin_bicep_kv_fw_rg)" \
     --parameters inputKeyvaultSubscription="$(admin_bicep_input_keyvault_subscription)" \
     --parameters projectServicePrincipleOID_SeedingKeyvaultName="$(project_service_principal_OID_seeding_kv_name)" \
     --parameters useAdGroups="$(use_ad_groups)" \
     --parameters disableAgentNetworkInjection="$(disableAgentNetworkInjection)" \
     --parameters enableAIFactoryCreatedDefaultProjectForAIFv2="$(enableAIFactoryCreatedDefaultProjectForAIFv2)" \
     --parameters containerAppsEnvExists="$(containerAppsEnvExists)" \
     --parameters enableCaphost="$(enableAFoundryCaphost)" \
     --parameters diagnosticSettingLevel="$(diagnosticSettingLevel)" \
     --parameters apiManagementResourceId="$(foundryApiManagementResourceId)" \
     --parameters foundryV22AccountOnly="true" \
     --parameters cmk="$(cmk)" \
     --parameters cmkKeyName="$(cmkKeyName)" \
     --parameters cmkKeyVersion="$(cmkKeyVersion)" \
     --parameters addAISearch="$(addAISearch)" \
     --parameters enableAIFoundry="$(enableAIFoundry)" \
     --parameters aiFoundryV2Exists="$(aiFoundryV2Exists)" \
     --parameters aiFoundryV2ProjectExists="$(aiFoundryV2ProjectExists)" \
     --parameters useAVMFoundry="false" \
     --parameters updateAIFoundry="$(updateAIFoundry)" \
     --parameters enableDefenderforAISubLevel="$(enableDefenderforAISubLevel)" \
     --parameters enableDefenderforAIResourceLevel="$(enableDefenderforAIResourceLevel)" \
     --parameters addAIFoundry="$(addAIFoundry)" \
     --debug
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '69-Rehydrate'
  condition: and(ne(variables['debug_disable_69_aifoundry_2025'], 'true'), not(failed()), not(canceled()), ne(variables['aiFoundryV2Exists'], 'true'), or(eq(variables['foundryDeploymentType'], '2'), eq(variables['foundryDeploymentType'], '3')))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     #!/bin/bash
     echo "Rehydration takes 2.5 to 5 minutes to allow AI Foundry account to finish..."
     sleep 15
- task: AzureCLI@2
  displayName: '69b-aifoundry-2025-2ndOption-AccountUpdate'
  condition: and(ne(variables['debug_disable_69_aifoundry_2025'], 'true'), succeeded(), ne(variables['foundry_1st_option_succeeded'], 'true'), or(eq(variables['foundryDeploymentType'], '2'), eq(variables['foundryDeploymentType'], '3')))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     az account set --subscription "$(dev_test_prod_sub_id)"
     az deployment sub create \
     --name "esml-p$(project_number_000)-$(dev_test_prod)-$(admin_locationSuffix)-$(admin_prjResourceSuffix)$(admin_commonResourceSuffix)$PrjDepl-69-aif-b" \
     --subscription "$(dev_test_prod_sub_id)" \
     --location "$(admin_location)" \
     --template-file "esml-genai-1/09-ai-foundry-2025-v4.bicep" \
     --parameters "@../../../../aifactory/parameters/dynamicNetworkParams.json" \
     --parameters env="$(dev_test_prod)" \
     --parameters projectNumber="$(project_number_000)" \
     --parameters location="$(admin_location)" \
     --parameters locationSuffix="$(admin_locationSuffix)" \
     --parameters commonResourceSuffix="$(admin_commonResourceSuffix)" \
     --parameters resourceSuffix="$(admin_prjResourceSuffix)" \
     --parameters enableAIFoundry="$(enableAIFoundry)" \
     --parameters enableAISearch="$(enableAISearch)" \
     --parameters enableCosmosDB="$(enableCosmosDB)" \
     --parameters deployModel_gpt_X="$(deployModel_gpt_X)" \
     --parameters modelGPTXName="$(modelGPTXName)" \
     --parameters modelGPTXVersion="$(modelGPTXVersion)" \
     --parameters modelGPTXSku="$(modelGPTXSku)" \
     --parameters modelGPTXCapacity="$(modelGPTXCapacity)" \
     --parameters deployModel_text_embedding_ada_002="$(deployModel_text_embedding_ada_002)" \
     --parameters deployModel_text_embedding_3_large="$(deployModel_text_embedding_3_large)" \
     --parameters deployModel_text_embedding_3_small="$(deployModel_text_embedding_3_small)" \
     --parameters default_embedding_capacity="$(default_embedding_capacity)" \
     --parameters default_gpt_capacity="$(default_gpt_capacity)" \
     --parameters deployModel_gpt_4o="$(deployModel_gpt_4o)" \
     --parameters default_gpt_4o_version="$(default_gpt_4o_version)" \
     --parameters deployModel_gpt_4o_mini="$(deployModel_gpt_4o_mini)" \
     --parameters default_gpt_4o_mini_version="$(default_gpt_4o_mini_version)" \
     --parameters default_model_sku="$(default_model_sku)" \
     --parameters enablePublicAccessWithPerimeter="$(enablePublicAccessWithPerimeter)" \
     --parameters enablePublicGenAIAccess="$(enablePublicGenAIAccess)" \
     --parameters allowPublicAccessWhenBehindVnet="$(allowPublicAccessWhenBehindVnet)" \
     --parameters IPwhiteList="$(project_IP_whitelist)" \
     --parameters centralDnsZoneByPolicyInHub="$(centralDnsZoneByPolicyInHub)" \
     --parameters vnetNameBase="$(vnetNameBase)" \
     --parameters vnetResourceGroup_param="$(vnetResourceGroup_resolved)" \
     --parameters vnetNameFull_param="$(vnetNameFull_resolved)" \
     --parameters network_env="$(network_env)" \
     --parameters common_subnet_name="$(common_subnet_name)" \
     --parameters subnetCommon="$(subnetCommon)" \
     --parameters privDnsSubscription_param="$(privDnsSubscription_param)" \
     --parameters privDnsResourceGroup_param="$(privDnsResourceGroup_param)" \
     --parameters commonResourceGroup_param="$(commonResourceGroup_param)" \
     --parameters tagsProject='$(tagsProject)' \
     --parameters aifactorySuffixRG="$(admin_aifactorySuffixRG)" \
     --parameters commonRGNamePrefix="$(admin_aifactoryPrefixRG)" \
     --parameters commonResourceName="$(vnetResourceGroupBase)" \
     --parameters aifactorySalt10char="$(aifactory_salt_random)" \
     --parameters randomValue="$(deployment_random_value)" \
     --parameters technicalAdminsObjectID="$(technical_admins_ad_object_id)" \
     --parameters technicalAdminsEmail="$(technical_admins_email)" \
     --parameters subscriptionIdDevTestProd="$(dev_test_prod_sub_id)" \
     --parameters projectPrefix="$(projectPrefix)" \
     --parameters projectSuffix="$(projectSuffix)" \
     --parameters inputKeyvault="$(admin_bicep_kv_fw)" \
     --parameters inputKeyvaultResourcegroup="$(admin_bicep_kv_fw_rg)" \
     --parameters inputKeyvaultSubscription="$(admin_bicep_input_keyvault_subscription)" \
     --parameters projectServicePrincipleOID_SeedingKeyvaultName="$(project_service_principal_OID_seeding_kv_name)" \
     --parameters useAdGroups="$(use_ad_groups)" \
     --parameters disableAgentNetworkInjection="$(disableAgentNetworkInjection)" \
     --parameters enableAIFactoryCreatedDefaultProjectForAIFv2="$(enableAIFactoryCreatedDefaultProjectForAIFv2)" \
     --parameters containerAppsEnvExists="$(containerAppsEnvExists)" \
     --parameters enableCaphost="$(enableAFoundryCaphost)" \
     --parameters diagnosticSettingLevel="$(diagnosticSettingLevel)" \
     --parameters apiManagementResourceId="$(foundryApiManagementResourceId)" \
     --parameters foundryV22AccountOnly="false" \
     --parameters cmk="$(cmk)" \
     --parameters cmkKeyName="$(cmkKeyName)" \
     --parameters cmkKeyVersion="$(cmkKeyVersion)" \
     --parameters addAISearch="$(addAISearch)" \
     --parameters useAVMFoundry="false" \
     --parameters updateAIFoundry="$(updateAIFoundry)" \
     --parameters aiFoundryV2Exists="$(aiFoundryV2Exists)" \
     --parameters aiFoundryV2ProjectExists="$(aiFoundryV2ProjectExists)" \
     --parameters enableDefenderforAISubLevel="$(enableDefenderforAISubLevel)" \
     --parameters enableDefenderforAIResourceLevel="$(enableDefenderforAIResourceLevel)" \
     --parameters addAIFoundry="$(addAIFoundry)"
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '100b_create_foundry_agent'
  condition: and(succeeded(), eq(variables['enableAIFoundry'], 'true'))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
     set -e
     
     az account set --subscription "$(dev_test_prod_sub_id)"
     
     echo "=== AI Foundry Agent Creation ==="
     
     # Build resource group name
     commonRGNamePrefix="$(admin_aifactoryPrefixRG)"
     projectNumber="$(project_number_000)"
     projectName="prj${projectNumber}"
     locationSuffix="$(admin_locationSuffix)"
     envName="$(dev_test_prod)"
     aifactorySuffixRG="$(admin_aifactorySuffixRG)"
     vnetResourceGroupBase="$(vnetResourceGroupBase)"
     projectPrefix="$(projectPrefix)"
     projectSuffix="$(projectSuffix)"
     projectNameReplaced="${projectName/prj/project}"
     projectResourceGroup="${commonRGNamePrefix}${projectPrefix}${projectNameReplaced}-${locationSuffix}-${envName}${aifactorySuffixRG}${projectSuffix}"
     
     echo "Target resource group: $projectResourceGroup"
     
     # Find the AI Foundry account (aif2* but not aif2-p*)
     echo "Searching for AI Foundry account..."
     foundry_account=$(az cognitiveservices account list \
       --subscription "$(dev_test_prod_sub_id)" \
       --resource-group "$projectResourceGroup" \
       --query "[?starts_with(name, 'aif2') && !starts_with(name, 'aif2-p')].{name:name, id:id}" \
       -o json | jq -r '.[0]')
     
     if [ "$foundry_account" = "null" ] || [ -z "$foundry_account" ]; then
       echo "‚ùå No AI Foundry account found in resource group. Skipping agent creation."
       exit 0
     fi
     
     account_name=$(echo "$foundry_account" | jq -r '.name')
     account_id=$(echo "$foundry_account" | jq -r '.id')
     
     echo "‚úÖ Found AI Foundry account: $account_name"
     
     # Find the AI Foundry project (aif2-p*)
     echo "Searching for AI Foundry project..."
     
     # Projects are sub-resources of the account - query via REST API
     project_list=$(az rest \
       --method GET \
       --url "https://management.azure.com${account_id}/aiServicesProjects?api-version=2024-04-01-preview" \
       --query "value[?starts_with(name, 'aif2-p${projectNumber}')].{name:name, id:id, endpoint:properties.discoveryUrl}" \
       -o json 2>/dev/null || echo "[]")
     
     project_info=$(echo "$project_list" | jq -r '.[0]')
     
     if [ "$project_info" = "null" ] || [ -z "$project_info" ]; then
       echo "‚ö†Ô∏è  No AI Foundry project found for project ${projectNumber}. Trying alternative approach..."
       
       # Alternative: List all projects and filter
       project_list=$(az rest \
         --method GET \
         --url "https://management.azure.com${account_id}/aiServicesProjects?api-version=2024-04-01-preview" \
         --query "value[].{name:name, id:id, endpoint:properties.discoveryUrl}" \
         -o json 2>/dev/null || echo "[]")
       
       project_info=$(echo "$project_list" | jq -r '.[0]')
       
       if [ "$project_info" = "null" ] || [ -z "$project_info" ]; then
         echo "‚ùå No AI Foundry projects found. Agent creation requires a project. Skipping."
         exit 0
       fi
     fi
     
     project_name=$(echo "$project_info" | jq -r '.name')
     project_id=$(echo "$project_info" | jq -r '.id')
     project_endpoint=$(echo "$project_info" | jq -r '.endpoint // empty')
     
     echo "‚úÖ Found AI Foundry project: $project_name"
     
     # If no discovery URL, construct from account endpoint
     if [ -z "$project_endpoint" ] || [ "$project_endpoint" = "null" ]; then
       account_endpoint=$(az cognitiveservices account show \
         --name "$account_name" \
         --resource-group "$projectResourceGroup" \
         --query "properties.endpoint" -o tsv)
       
       # Remove trailing slash from account endpoint
       account_endpoint=$(echo "$account_endpoint" | sed 's:/*$::')
       
       # Construct project endpoint
       project_endpoint="${account_endpoint}/projects/${project_name}"
       echo "Constructed project endpoint: $project_endpoint"
     else
       echo "Using project discovery endpoint: $project_endpoint"
     fi
     
     # Get access token
     echo "Acquiring access token..."
     access_token=$(az account get-access-token \
       --resource https://cognitiveservices.azure.com/ \
       --query accessToken -o tsv)
     
     if [ -z "$access_token" ]; then
       echo "‚ùå Failed to acquire access token. Skipping agent creation."
       exit 0
     fi
     
     # Try to create agent with correct project-scoped endpoint
     echo "Creating agent 'agent-001' in project..."
     
     payload='{"name":"agent-001","model":"gpt-4o-mini","description":"Pipeline-created agent","instructions":"You are a helpful AI assistant.","metadata":{"source":"ado-pipeline"}}'
     
     # Try multiple API versions and paths
     api_versions=("2024-10-01-preview" "2024-07-01-preview" "2024-05-01-preview")
     agent_created=false
     
     for api_version in "${api_versions[@]}"; do
       echo "Attempting with API version: $api_version"
       
       # Remove trailing slash and construct proper URL
       base_url=$(echo "$project_endpoint" | sed 's:/*$::')
       agent_url="${base_url}/agents?api-version=${api_version}"
       
       echo "POST URL: $agent_url"
       
       response=$(curl -sS -w "\nHTTP_STATUS:%{http_code}" -X POST "$agent_url" \
         -H "Content-Type: application/json" \
         -H "Authorization: Bearer $access_token" \
         -d "$payload" 2>&1 || echo "CURL_ERROR")
       
       http_status=$(echo "$response" | grep "HTTP_STATUS" | cut -d: -f2)
       response_body=$(echo "$response" | sed '/HTTP_STATUS/d')
       
       echo "Response (HTTP $http_status): $response_body"
       
       if [ "$http_status" = "200" ] || [ "$http_status" = "201" ]; then
         echo "‚úÖ Agent created successfully!"
         agent_created=true
         echo "##vso[task.setvariable variable=foundryAgentCreated]true"
         break
       elif [ "$http_status" = "409" ]; then
         echo "‚ÑπÔ∏è  Agent already exists (409 Conflict)"
         agent_created=true
         echo "##vso[task.setvariable variable=foundryAgentCreated]true"
         break
       else
         echo "‚ö†Ô∏è  Attempt failed with API version $api_version"
       fi
     done
     
     if [ "$agent_created" = false ]; then
       echo "‚ùå Failed to create agent with all attempted API versions."
       echo "This may require using Azure AI Foundry SDK or portal to create agents."
       echo "##vso[task.setvariable variable=foundryAgentCreated]false"
     fi
     
     echo "=== Agent creation task completed ==="
- task: AzureCLI@2
  displayName: '101_generate_hosts_file_info'
  condition: succeeded()
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: scriptPath
    scriptPath: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep/scripts/ado/70_generate_hosts_file_info.sh'
    arguments: $(dev_test_prod_sub_id) $(admin_aifactoryPrefixRG) $(project_number_000) $(admin_locationSuffix) $(dev_test_prod) $(admin_aifactorySuffixRG) $(admin_prjResourceSuffix) $(aifactory_salt) $(aifactory_salt_random) $(deployment_random_value) $(projectPrefix) $(projectSuffix)
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '111_If_Error_AIFoundryHubAndProject_DeleteIt'
  condition: and(failed(), eq(variables['debugEnableCleaning'], 'true'), or(contains(variables['Agent.JobStatus'], '66-ai-platform'), eq(variables['System.StageResult'], 'Failed')))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: scriptPath
    scriptPath: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep/scripts/ado/71_If_Error_AIFoundryHubAndProject_DeleteIt.sh'
    arguments: $(dev_test_prod_sub_id) $(admin_aifactoryPrefixRG) $(project_number_000) $(admin_locationSuffix) $(dev_test_prod) $(admin_aifactorySuffixRG) $(admin_prjResourceSuffix) $(aifactory_salt) $(aifactory_salt_random) $(deployment_random_value) $(projectPrefix) $(projectSuffix)
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '112_If_Error_AIServices_DeleteIt'
  condition: and(failed(), eq(variables['debugEnableCleaning'], 'true'), or(contains(variables['Agent.JobStatus'], '63-cognitive-services'), eq(variables['System.StageResult'], 'Failed')))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: scriptPath
    scriptPath: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep/scripts/ado/72_If_Error_AIServices_DeleteIt.sh'
    arguments: $(dev_test_prod_sub_id) $(admin_aifactoryPrefixRG) $(project_number_000) $(admin_locationSuffix) $(dev_test_prod) $(admin_aifactorySuffixRG) $(admin_prjResourceSuffix) $(aifactory_salt) $(aifactory_salt_random) $(deployment_random_value) $(projectPrefix) $(projectSuffix)
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '113_If_Error_AIFoundryProject_DeleteIt'
  condition: and(failed(), eq(variables['debugEnableCleaning'], 'true'), or(contains(variables['Agent.JobStatus'], '69-aifoundry-2025'), eq(variables['System.StageResult'], 'Failed')))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: scriptPath
    scriptPath: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep/scripts/ado/73_If_Error_AIFoundryProject_DeleteIt.sh'
    arguments: $(dev_test_prod_sub_id) $(admin_aifactoryPrefixRG) $(project_number_000) $(admin_locationSuffix) $(dev_test_prod) $(admin_aifactorySuffixRG) $(admin_prjResourceSuffix) $(aifactory_salt) $(aifactory_salt_random) $(deployment_random_value) $(projectPrefix) $(projectSuffix)
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '114_Purge_If_SoftDeleted_111_112_After5minutes'
  condition: and(eq(variables['debugEnableCleaning'], 'true'), or(eq(variables['71_deleted'], 'true'), eq(variables['72_deleted'], 'true')))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: scriptPath
    scriptPath: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep/scripts/ado/79_Purge_If_SoftDeleted_71_72_After5minutes.sh'
    arguments: $(dev_test_prod_sub_id) $(admin_aifactoryPrefixRG) $(project_number_000) $(admin_locationSuffix) $(dev_test_prod) $(admin_aifactorySuffixRG) $(admin_prjResourceSuffix) $(aifactory_salt) $(aifactory_salt_random) $(deployment_random_value) $(projectPrefix) $(projectSuffix) $(71_deleted) $(72_deleted) $(admin_location)
    workingDirectory: '$(System.DefaultWorkingDirectory)/azure-enterprise-scale-ml/environment_setup/aifactory/bicep'
- task: AzureCLI@2
  displayName: '07_az_remove_ip_from_seeding_keyvault_FW_whitelist'
  condition: and(always(), ne(variables['disable_whitelisting_for_build_agents'], 'true'))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptLocation: inlineScript
    scriptType: bash
    inlineScript: | 
     az account set --subscription "$(admin_bicep_input_keyvault_subscription)"
     az keyvault network-rule remove --resource-group "$(admin_bicep_kv_fw_rg)" --name "$(admin_bicep_kv_fw)" --ip-address "$(admin_ip_fw)"
- task: AzureCLI@2
  displayName: '08_az_remove_ips_from_ACR_FW_whitelist'
  condition: and(always(), ne(variables['disable_whitelisting_for_build_agents'], 'true'))
  inputs:
    azureSubscription: ${{ parameters.serviceConnection }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
      # Get the registry name and IPs from previous task
      registryName="$(acr_registry_name)"
      added_ips_string="$(acr_added_ips)"
      
      # Debug flag to skip export policy disable (for testing)
      debug_keep_exportPolicy=true

      echo "Registry name: $registryName"
      echo "IPs to remove: $added_ips_string"

      # Check if we have IPs to remove
      if [ -n "$added_ips_string" ]; then
        echo "Cleaning up: Removing IPs and ranges that were added during ACR operations"

        # Convert comma-separated string to array
        IFS=',' read -ra ADDED_IPS <<< "$added_ips_string"

        for ip in "${ADDED_IPS[@]}"; do
          if [ -n "$ip" ]; then
            echo "Removing IP/range from ACR whitelist: $ip"
            az acr network-rule remove --name "$registryName" --ip-address "$ip" || echo "Failed to remove $ip or it was already removed"
          fi
        done

        echo "ACR firewall cleanup completed."
      else
        echo "No IPs to remove from ACR"
      fi

      # Secure the ACR by disabling public network access
      if [ -n "$registryName" ]; then
        echo "Disabling public network access for ACR: $registryName"
        az acr update --name "$registryName" --public-network-enabled false || echo "Failed to disable public access for $registryName"
        echo "ACR public network access disabled for security."
        
        # Configure ACR export policy using REST API - only disable if fully private and debug flag is false
        if [ "$debug_keep_exportPolicy" = "false" ] && [ "$(allowPublicAccessWhenBehindVnet)" = "false" ] && [ "$(enablePublicGenAIAccess)" = "false" ] && [ "$(enablePublicAccessWithPerimeter)" = "false" ]; then
          echo "Disabling ACR export policy (fully private configuration)"
          acrResourceGroup=$(az acr show --name "$registryName" --query resourceGroup -o tsv)
          echo "ACR Resource Group: $acrResourceGroup"
          az rest --method patch \
            --url "https://management.azure.com/subscriptions/$(dev_test_prod_sub_id)/resourceGroups/$acrResourceGroup/providers/Microsoft.ContainerRegistry/registries/$registryName?api-version=2023-07-01" \
            --body '{"properties":{"policies":{"exportPolicy":{"status":"disabled"}}}}'
        else
          if [ "$debug_keep_exportPolicy" = "true" ]; then
            echo "Skipping ACR export policy disable - debug_keep_exportPolicy is set to true"
          else
            echo "Skipping ACR export policy disable - public access is enabled"
          fi
        fi
      else
        echo "No registry name found - skipping public access disable"
      fi
